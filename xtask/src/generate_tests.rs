use std::collections::{HashMap, HashSet};
use std::fmt::Write as _;
use std::fs;
use std::io::{BufWriter, Write as _};
use std::str::FromStr;

use convert_case::{Case, Casing};
use lazy_static::lazy_static;
use proc_macro2::TokenStream;
use purl::PackageType;
use quote::{format_ident, quote};
use regex::Regex;
use serde::Deserialize;
use syn::parse_quote;

use crate::workspace_dir;

const TEST_SUITE_DATA: &str = include_str!("generate_tests/test-suite-data.json");
const PHYLUM_TEST_SUITE_DATA: &str = include_str!("generate_tests/phylum-test-suite-data.json");
const BLACKLIST: &[&str] = &[
    // NuGet package names are not case sensitive. package-url/purl-spec#226
    "nuget names are case sensitive",
    // These tests fail because we don't support type-specific rules for these types.
    "Hugging Face model with various cases",
    "MLflow model tracked in Azure Databricks (case insensitive)",
    "bitbucket namespace and name should be lowercased",
    "composer names are not case sensitive",
    "cpan distribution name like module name",
    "cpan module name like distribution name",
    "github namespace and name should be lowercased",
    "invalid conan purl only channel qualifier",
    "invalid conan purl only namespace",
    "invalid cran purl without version",
    "invalid swift purl without namespace",
    "invalid swift purl without version",
    // This test is currently wrong. package-url/purl-spec#416
    "docker uses qualifiers and hash image id as versions",
    // Currently broken. https://github.com/package-url/purl-spec/pull/409#issuecomment-2707669822
    "invalid encoded colon : between scheme and type",
];

lazy_static! {
    static ref UNDERSCORES: Regex = Regex::new("__+").unwrap();
}

#[derive(Deserialize)]
struct Test<'a> {
    description: &'a str,
    purl: &'a str,
    canonical_purl: Option<&'a str>,
    r#type: Option<&'a str>,
    namespace: Option<&'a str>,
    name: Option<&'a str>,
    version: Option<&'a str>,
    qualifiers: Option<HashMap<&'a str, &'a str>>,
    subpath: Option<&'a str>,
    is_invalid: bool,
}

pub fn main() {
    let purl_tests: Vec<Test> =
        serde_json::from_str(TEST_SUITE_DATA).expect("Could not read test-suite-data.json");
    let phylum_tests: Vec<Test> = serde_json::from_str(PHYLUM_TEST_SUITE_DATA)
        .expect("Could not read phylum-test-suite-data.json");

    let mut names = HashSet::new();
    let tests = purl_tests
        .into_iter()
        .chain(phylum_tests)
        .filter(|t| !BLACKLIST.contains(&t.description))
        .map(|t| test_to_tokens(t, &mut names));
    let suite = parse_quote! {
        use std::str::FromStr;
        use purl::{GenericPurl, PackageError, PackageType, ParseError, Purl};

        #(#tests)*
    };

    let file = fs::File::create(workspace_dir().join("purl_test/src/lib.rs"))
        .expect("Could not create test_suite.rs");
    let mut file = BufWriter::new(file);

    writeln!(file, "// This file is autogenerated by generate_tests.rs.").unwrap();
    writeln!(file, "// Use `cargo xtask codegen` to regenerate it.").unwrap();
    writeln!(file, "#![cfg(test)]").unwrap();
    writeln!(file).unwrap();
    writeln!(file, "{}", prettyplease::unparse(&suite)).unwrap();
}

fn test_to_tokens(test: Test, names: &mut HashSet<String>) -> Option<TokenStream> {
    let Test {
        description,
        purl,
        canonical_purl,
        r#type,
        namespace,
        name,
        version,
        qualifiers,
        subpath,
        is_invalid,
    } = test;

    let test_name = description.to_case(Case::Snake).replace(|c: char| !c.is_alphanumeric(), "_");
    let mut test_name = UNDERSCORES.replace_all(&test_name, "_");
    // Handle duplicate names after sanitization.
    if names.contains(&*test_name) {
        let test_name = test_name.to_mut();
        while test_name.ends_with('_') {
            test_name.truncate(test_name.len() - 1);
        }
        let base_len = test_name.len() + 1;
        test_name.push_str("_1");
        let mut number = 1;
        while names.contains(test_name) {
            test_name.truncate(base_len);
            number += 1;
            write!(test_name, "{number}").unwrap();
        }
    }
    names.insert(test_name.clone().into_owned());
    let test_name = format_ident!("{test_name}");

    let parse;
    let parse_canonical;
    let error_type;
    let mut builder;
    // Check if this type is supported by this library.
    if let Some(parsed_type) = r#type.and_then(|t| PackageType::from_str(t).ok()) {
        parse = quote! {
            Purl::from_str(#purl)
        };
        parse_canonical = canonical_purl.map(|canonical_purl| {
            quote! {
                Purl::from_str(#canonical_purl)
            }
        });
        error_type = quote! { PackageError };
        builder = name.map(|name| {
            let type_tokens = type_to_tokens(parsed_type);
            quote! {
                Purl::builder(#type_tokens, #name)
            }
        });
    } else {
        // For all the unsupported cases, we can still verify the ability to handle them
        // without type-specific rules.
        // If the type-specific rules are required for the test to pass, the test needs
        // to be added to BLACKLIST.
        parse = quote! {
            GenericPurl::<String>::from_str(#purl)
        };
        parse_canonical = canonical_purl.map(|canonical_purl| {
            quote! {
                GenericPurl::<String>::from_str(#canonical_purl)
            }
        });
        error_type = quote! { ParseError };
        builder = r#type.zip(name).map(|(r#type, name)| {
            quote! {
                GenericPurl::builder(#r#type.to_owned(), #name)
            }
        });
    };

    if let Some(builder) = builder.as_mut() {
        if let Some(namespace) = namespace {
            *builder = quote! {
                #builder.with_namespace(#namespace)
            };
        }
        if let Some(version) = version {
            *builder = quote! {
                #builder.with_version(#version)
            };
        }
        *builder = quote! {
            Result::<_, #error_type>::Ok(#builder)
        };
        let mut qualifiers: Vec<_> = qualifiers.into_iter().flatten().collect();
        qualifiers.sort_unstable();
        for (key, value) in qualifiers {
            *builder = quote! {
                #builder.and_then(|builder| Ok(builder.with_qualifier(#key, #value)?))
            };
        }
        if let Some(subpath) = subpath {
            *builder = quote! {
                #builder.map(|builder| builder.with_subpath(#subpath))
            };
        }
    }

    Some(if is_invalid {
        let from_parts_test = builder.map(|builder| {
            let test_name = format_ident!("{test_name}_from_parts");
            quote! {
                #[test]
                #[doc = #description]
                fn #test_name() {
                    assert!(#builder.and_then(|builder| builder.build()).is_err(), "Invalid PURL should not parse");
                }
            }
        });

        quote! {
            #[test]
            #[doc = #description]
            fn #test_name() {
                assert!(#parse.is_err(), "Invalid PURL should not build from parts");
            }

            #from_parts_test
        }
    } else {
        let parsed_canonical = format_ident!("canonical");

        let from_parts_fragment = builder.map(|builder| quote! {
            let from_parts = #builder
                .and_then(|builder| builder.build())
                .expect("Constructing valid PURL from parts should succeed");

            assert_eq!(#parsed_canonical, from_parts, "Constructing PURL from parts should result in canonical PURL");
        });

        quote! {
            #[test]
            #[doc = #description]
            fn #test_name() {
                let #parsed_canonical = #parse_canonical.expect("Canonical PURL should parse");
                assert_eq!(
                    #canonical_purl,
                    #parsed_canonical.to_string(),
                    "Parsed canonical PURL should format as the same string",
                );

                let parsed = #parse.expect("Test PURL should parse");
                assert_eq!(#parsed_canonical, parsed, "Test PURL should parse as canonical PURL");

                #from_parts_fragment
            }
        }
    })
}

fn type_to_tokens(value: PackageType) -> TokenStream {
    let ident = format_ident!("{}", format!("{:?}", value));
    quote! { PackageType::#ident }
}
