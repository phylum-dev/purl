// This file is autogenerated by generate_tests.rs.
// Use `cargo xtask codegen` to regenerate it.
#![cfg(test)]

use std::str::FromStr;

use purl::{GenericPurl, PackageError, PackageType, ParseError, Purl};
#[test]
/// valid maven purl
fn valid_maven_purl() {
    let canonical = Purl::from_str("pkg:maven/org.apache.commons/io@1.3.4")
        .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:maven/org.apache.commons/io@1.3.4",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed =
        Purl::from_str("pkg:maven/org.apache.commons/io@1.3.4").expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(
        Purl::builder(PackageType::Maven, "io")
            .with_namespace("org.apache.commons")
            .with_version("1.3.4"),
    )
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// basic valid maven purl without version
fn basic_valid_maven_purl_without_version() {
    let canonical =
        Purl::from_str("pkg:maven/org.apache.commons/io").expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:maven/org.apache.commons/io",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = Purl::from_str("pkg:maven/org.apache.commons/io").expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(
        Purl::builder(PackageType::Maven, "io").with_namespace("org.apache.commons"),
    )
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// valid go purl without version and with subpath
fn valid_go_purl_without_version_and_with_subpath() {
    let canonical =
        Purl::from_str("pkg:golang/google.golang.org/genproto#googleapis/api/annotations")
            .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:golang/google.golang.org/genproto#googleapis/api/annotations",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed =
        Purl::from_str("pkg:GOLANG/google.golang.org/genproto#/googleapis/api/annotations/")
            .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(
        Purl::builder(PackageType::Golang, "genproto").with_namespace("google.golang.org"),
    )
    .map(|builder| builder.with_subpath("googleapis/api/annotations"))
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// valid go purl with version and subpath
fn valid_go_purl_with_version_and_subpath() {
    let canonical =
        Purl::from_str("pkg:golang/google.golang.org/genproto@abcdedf#googleapis/api/annotations")
            .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:golang/google.golang.org/genproto@abcdedf#googleapis/api/annotations",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = Purl::from_str(
        "pkg:GOLANG/google.golang.org/genproto@abcdedf#/googleapis/api/annotations/",
    )
    .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(
        Purl::builder(PackageType::Golang, "genproto")
            .with_namespace("google.golang.org")
            .with_version("abcdedf"),
    )
    .map(|builder| builder.with_subpath("googleapis/api/annotations"))
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// invalid subpath - unencoded subpath cannot contain '..'
fn invalid_subpath_unencoded_subpath_cannot_contain_() {
    let canonical =
        Purl::from_str("pkg:golang/google.golang.org/genproto@abcdedf#googleapis/api/annotations")
            .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:golang/google.golang.org/genproto@abcdedf#googleapis/api/annotations",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = Purl::from_str(
        "pkg:GOLANG/google.golang.org/genproto@abcdedf#/googleapis/%2E%2E/api/annotations/",
    )
    .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(
        Purl::builder(PackageType::Golang, "genproto")
            .with_namespace("google.golang.org")
            .with_version("abcdedf"),
    )
    .map(|builder| builder.with_subpath("googleapis/../api/annotations"))
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// invalid subpath - unencoded subpath cannot contain '.'
fn invalid_subpath_unencoded_subpath_cannot_contain_1() {
    let canonical =
        Purl::from_str("pkg:golang/google.golang.org/genproto@abcdedf#googleapis/api/annotations")
            .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:golang/google.golang.org/genproto@abcdedf#googleapis/api/annotations",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = Purl::from_str(
        "pkg:GOLANG/google.golang.org/genproto@abcdedf#/googleapis/%2E/api/annotations/",
    )
    .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(
        Purl::builder(PackageType::Golang, "genproto")
            .with_namespace("google.golang.org")
            .with_version("abcdedf"),
    )
    .map(|builder| builder.with_subpath("googleapis/./api/annotations"))
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// debian can use qualifiers
fn debian_can_use_qualifiers() {
    let canonical =
        GenericPurl::<String>::from_str("pkg:deb/debian/curl@7.50.3-1?arch=i386&distro=jessie")
            .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:deb/debian/curl@7.50.3-1?arch=i386&distro=jessie",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed =
        GenericPurl::<String>::from_str("pkg:deb/debian/curl@7.50.3-1?arch=i386&distro=jessie")
            .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, ParseError>::Ok(
        GenericPurl::builder("deb".to_owned(), "curl")
            .with_namespace("debian")
            .with_version("7.50.3-1"),
    )
    .and_then(|builder| Ok(builder.with_qualifier("arch", "i386")?))
    .and_then(|builder| Ok(builder.with_qualifier("distro", "jessie")?))
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// Java gem can use a qualifier
fn java_gem_can_use_a_qualifier() {
    let canonical = Purl::from_str("pkg:gem/jruby-launcher@1.1.2?platform=java")
        .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:gem/jruby-launcher@1.1.2?platform=java",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = Purl::from_str("pkg:gem/jruby-launcher@1.1.2?Platform=java")
        .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(
        Purl::builder(PackageType::Gem, "jruby-launcher").with_version("1.1.2"),
    )
    .and_then(|builder| Ok(builder.with_qualifier("platform", "java")?))
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// maven often uses qualifiers
fn maven_often_uses_qualifiers() {
    let canonical = Purl::from_str(
        "pkg:maven/org.apache.xmlgraphics/batik-anim@1.9.1?classifier=sources&repository_url=repo.\
         spring.io/release",
    )
    .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:maven/org.apache.xmlgraphics/batik-anim@1.9.1?classifier=sources&repository_url=repo.\
         spring.io/release",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = Purl::from_str(
        "pkg:Maven/org.apache.xmlgraphics/batik-anim@1.9.1?classifier=sources&repositorY_url=repo.\
         spring.io/release",
    )
    .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(
        Purl::builder(PackageType::Maven, "batik-anim")
            .with_namespace("org.apache.xmlgraphics")
            .with_version("1.9.1"),
    )
    .and_then(|builder| Ok(builder.with_qualifier("classifier", "sources")?))
    .and_then(|builder| Ok(builder.with_qualifier("repository_url", "repo.spring.io/release")?))
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// maven pom reference
fn maven_pom_reference() {
    let canonical = Purl::from_str(
        "pkg:maven/org.apache.xmlgraphics/batik-anim@1.9.1?extension=pom&repository_url=repo.\
         spring.io/release",
    )
    .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:maven/org.apache.xmlgraphics/batik-anim@1.9.1?extension=pom&repository_url=repo.\
         spring.io/release",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = Purl::from_str(
        "pkg:Maven/org.apache.xmlgraphics/batik-anim@1.9.1?extension=pom&repositorY_url=repo.\
         spring.io/release",
    )
    .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(
        Purl::builder(PackageType::Maven, "batik-anim")
            .with_namespace("org.apache.xmlgraphics")
            .with_version("1.9.1"),
    )
    .and_then(|builder| Ok(builder.with_qualifier("extension", "pom")?))
    .and_then(|builder| Ok(builder.with_qualifier("repository_url", "repo.spring.io/release")?))
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// maven can come with a type qualifier
fn maven_can_come_with_a_type_qualifier() {
    let canonical =
        Purl::from_str("pkg:maven/net.sf.jacob-project/jacob@1.14.3?classifier=x86&type=dll")
            .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:maven/net.sf.jacob-project/jacob@1.14.3?classifier=x86&type=dll",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed =
        Purl::from_str("pkg:Maven/net.sf.jacob-project/jacob@1.14.3?classifier=x86&type=dll")
            .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(
        Purl::builder(PackageType::Maven, "jacob")
            .with_namespace("net.sf.jacob-project")
            .with_version("1.14.3"),
    )
    .and_then(|builder| Ok(builder.with_qualifier("classifier", "x86")?))
    .and_then(|builder| Ok(builder.with_qualifier("type", "dll")?))
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// npm can be scoped
fn npm_can_be_scoped() {
    let canonical =
        Purl::from_str("pkg:npm/%40angular/animation@12.3.1").expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:npm/%40angular/animation@12.3.1",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed =
        Purl::from_str("pkg:npm/%40angular/animation@12.3.1").expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(
        Purl::builder(PackageType::Npm, "animation")
            .with_namespace("@angular")
            .with_version("12.3.1"),
    )
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// pypi names have special rules and not case sensitive
fn pypi_names_have_special_rules_and_not_case_sensitive() {
    let canonical =
        Purl::from_str("pkg:pypi/django-package@1.11.1.dev1").expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:pypi/django-package@1.11.1.dev1",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed =
        Purl::from_str("pkg:PYPI/Django_package@1.11.1.dev1").expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(
        Purl::builder(PackageType::PyPI, "django-package").with_version("1.11.1.dev1"),
    )
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// rpm often use qualifiers
fn rpm_often_use_qualifiers() {
    let canonical = GenericPurl::<String>::from_str(
        "pkg:rpm/fedora/curl@7.50.3-1.fc25?arch=i386&distro=fedora-25",
    )
    .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:rpm/fedora/curl@7.50.3-1.fc25?arch=i386&distro=fedora-25",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = GenericPurl::<String>::from_str(
        "pkg:Rpm/fedora/curl@7.50.3-1.fc25?Arch=i386&Distro=fedora-25",
    )
    .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, ParseError>::Ok(
        GenericPurl::builder("rpm".to_owned(), "curl")
            .with_namespace("fedora")
            .with_version("7.50.3-1.fc25"),
    )
    .and_then(|builder| Ok(builder.with_qualifier("arch", "i386")?))
    .and_then(|builder| Ok(builder.with_qualifier("distro", "fedora-25")?))
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// a scheme is always required
fn a_scheme_is_always_required() {
    assert!(
        GenericPurl::<String>::from_str("EnterpriseLibrary.Common@6.0.1304").is_err(),
        "Invalid PURL should not build from parts"
    );
}
#[test]
/// a type is always required
fn a_type_is_always_required() {
    assert!(
        GenericPurl::<String>::from_str("pkg:EnterpriseLibrary.Common@6.0.1304").is_err(),
        "Invalid PURL should not build from parts"
    );
}
#[test]
/// a name is required
fn a_name_is_required() {
    assert!(
        Purl::from_str("pkg:maven/@1.3.4").is_err(),
        "Invalid PURL should not build from parts"
    );
}
#[test]
/// slash / after scheme is not significant
fn slash_after_scheme_is_not_significant() {
    let canonical =
        Purl::from_str("pkg:maven/org.apache.commons/io").expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:maven/org.apache.commons/io",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed =
        Purl::from_str("pkg:/maven/org.apache.commons/io").expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(
        Purl::builder(PackageType::Maven, "io").with_namespace("org.apache.commons"),
    )
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// double slash // after scheme is not significant
fn double_slash_after_scheme_is_not_significant() {
    let canonical =
        Purl::from_str("pkg:maven/org.apache.commons/io").expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:maven/org.apache.commons/io",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed =
        Purl::from_str("pkg://maven/org.apache.commons/io").expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(
        Purl::builder(PackageType::Maven, "io").with_namespace("org.apache.commons"),
    )
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// slash /// after scheme is not significant
fn slash_after_scheme_is_not_significant_1() {
    let canonical =
        Purl::from_str("pkg:maven/org.apache.commons/io").expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:maven/org.apache.commons/io",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed =
        Purl::from_str("pkg:///maven/org.apache.commons/io").expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(
        Purl::builder(PackageType::Maven, "io").with_namespace("org.apache.commons"),
    )
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// valid maven purl with case sensitive namespace and name
fn valid_maven_purl_with_case_sensitive_namespace_and_name() {
    let canonical = Purl::from_str("pkg:maven/HTTPClient/HTTPClient@0.3-3")
        .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:maven/HTTPClient/HTTPClient@0.3-3",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed =
        Purl::from_str("pkg:maven/HTTPClient/HTTPClient@0.3-3").expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(
        Purl::builder(PackageType::Maven, "HTTPClient")
            .with_namespace("HTTPClient")
            .with_version("0.3-3"),
    )
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// valid maven purl containing a space in the version and qualifier
fn valid_maven_purl_containing_a_space_in_the_version_and_qualifier() {
    let canonical = Purl::from_str("pkg:maven/mygroup/myartifact@1.0.0%20Final?mykey=my%20value")
        .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:maven/mygroup/myartifact@1.0.0%20Final?mykey=my%20value",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = Purl::from_str("pkg:maven/mygroup/myartifact@1.0.0%20Final?mykey=my%20value")
        .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(
        Purl::builder(PackageType::Maven, "myartifact")
            .with_namespace("mygroup")
            .with_version("1.0.0 Final"),
    )
    .and_then(|builder| Ok(builder.with_qualifier("mykey", "my value")?))
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// checks for invalid qualifier keys
fn checks_for_invalid_qualifier_keys() {
    assert!(
        Purl::from_str("pkg:npm/myartifact@1.0.0?in%20production=true").is_err(),
        "Invalid PURL should not build from parts"
    );
}
#[test]
/// checks for invalid qualifier keys
fn checks_for_invalid_qualifier_keys_from_parts() {
    assert!(
        Result::<_, PackageError>::Ok(
            Purl::builder(PackageType::Npm, "myartifact").with_version("1.0.0")
        )
        .and_then(|builder| Ok(builder.with_qualifier("in production", "true")?))
        .and_then(|builder| builder.build())
        .is_err(),
        "Invalid PURL should not parse"
    );
}
#[test]
/// valid conan purl
fn valid_conan_purl() {
    let canonical =
        GenericPurl::<String>::from_str("pkg:conan/cctz@2.3").expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:conan/cctz@2.3",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed =
        GenericPurl::<String>::from_str("pkg:conan/cctz@2.3").expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, ParseError>::Ok(
        GenericPurl::builder("conan".to_owned(), "cctz").with_version("2.3"),
    )
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// valid conan purl with namespace and qualifier channel
fn valid_conan_purl_with_namespace_and_qualifier_channel() {
    let canonical =
        GenericPurl::<String>::from_str("pkg:conan/bincrafters/cctz@2.3?channel=stable")
            .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:conan/bincrafters/cctz@2.3?channel=stable",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = GenericPurl::<String>::from_str("pkg:conan/bincrafters/cctz@2.3?channel=stable")
        .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, ParseError>::Ok(
        GenericPurl::builder("conan".to_owned(), "cctz")
            .with_namespace("bincrafters")
            .with_version("2.3"),
    )
    .and_then(|builder| Ok(builder.with_qualifier("channel", "stable")?))
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// valid conda purl with qualifiers
fn valid_conda_purl_with_qualifiers() {
    let canonical = GenericPurl::<String>::from_str(
        "pkg:conda/absl-py@0.4.1?build=py36h06a4308_0&channel=main&subdir=linux-64&type=tar.bz2",
    )
    .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:conda/absl-py@0.4.1?build=py36h06a4308_0&channel=main&subdir=linux-64&type=tar.bz2",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = GenericPurl::<String>::from_str(
        "pkg:conda/absl-py@0.4.1?build=py36h06a4308_0&channel=main&subdir=linux-64&type=tar.bz2",
    )
    .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, ParseError>::Ok(
        GenericPurl::builder("conda".to_owned(), "absl-py").with_version("0.4.1"),
    )
    .and_then(|builder| Ok(builder.with_qualifier("build", "py36h06a4308_0")?))
    .and_then(|builder| Ok(builder.with_qualifier("channel", "main")?))
    .and_then(|builder| Ok(builder.with_qualifier("subdir", "linux-64")?))
    .and_then(|builder| Ok(builder.with_qualifier("type", "tar.bz2")?))
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// valid cran purl
fn valid_cran_purl() {
    let canonical =
        GenericPurl::<String>::from_str("pkg:cran/A3@0.9.1").expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:cran/A3@0.9.1",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed =
        GenericPurl::<String>::from_str("pkg:cran/A3@0.9.1").expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, ParseError>::Ok(
        GenericPurl::builder("cran".to_owned(), "A3").with_version("0.9.1"),
    )
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// invalid cran purl without name
fn invalid_cran_purl_without_name() {
    assert!(
        GenericPurl::<String>::from_str("pkg:cran/@0.9.1").is_err(),
        "Invalid PURL should not build from parts"
    );
}
#[test]
/// valid swift purl
fn valid_swift_purl() {
    let canonical =
        GenericPurl::<String>::from_str("pkg:swift/github.com/Alamofire/Alamofire@5.4.3")
            .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:swift/github.com/Alamofire/Alamofire@5.4.3",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = GenericPurl::<String>::from_str("pkg:swift/github.com/Alamofire/Alamofire@5.4.3")
        .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, ParseError>::Ok(
        GenericPurl::builder("swift".to_owned(), "Alamofire")
            .with_namespace("github.com/Alamofire")
            .with_version("5.4.3"),
    )
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// invalid swift purl without name
fn invalid_swift_purl_without_name() {
    assert!(
        GenericPurl::<String>::from_str("pkg:swift/github.com/Alamofire/@5.4.3").is_err(),
        "Invalid PURL should not build from parts"
    );
}
#[test]
/// valid hackage purl
fn valid_hackage_purl() {
    let canonical = GenericPurl::<String>::from_str("pkg:hackage/AC-HalfInteger@1.2.1")
        .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:hackage/AC-HalfInteger@1.2.1",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = GenericPurl::<String>::from_str("pkg:hackage/AC-HalfInteger@1.2.1")
        .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, ParseError>::Ok(
        GenericPurl::builder("hackage".to_owned(), "AC-HalfInteger").with_version("1.2.1"),
    )
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// name and version are always required
fn name_and_version_are_always_required() {
    assert!(
        GenericPurl::<String>::from_str("pkg:hackage").is_err(),
        "Invalid PURL should not build from parts"
    );
}
#[test]
/// minimal Hugging Face model
fn minimal_hugging_face_model() {
    let canonical = GenericPurl::<String>::from_str(
        "pkg:huggingface/distilbert-base-uncased@043235d6088ecd3dd5fb5ca3592b6913fd516027",
    )
    .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:huggingface/distilbert-base-uncased@043235d6088ecd3dd5fb5ca3592b6913fd516027",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = GenericPurl::<String>::from_str(
        "pkg:huggingface/distilbert-base-uncased@043235d6088ecd3dd5fb5ca3592b6913fd516027",
    )
    .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, ParseError>::Ok(
        GenericPurl::builder("huggingface".to_owned(), "distilbert-base-uncased")
            .with_version("043235d6088ecd3dd5fb5ca3592b6913fd516027"),
    )
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// Hugging Face model with staging endpoint
fn hugging_face_model_with_staging_endpoint() {
    let canonical = GenericPurl::<
        String,
    >::from_str(
            "pkg:huggingface/microsoft/deberta-v3-base@559062ad13d311b87b2c455e67dcd5f1c8f65111?repository_url=https://hub-ci.huggingface.co",
        )
        .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:huggingface/microsoft/deberta-v3-base@559062ad13d311b87b2c455e67dcd5f1c8f65111?repository_url=https://hub-ci.huggingface.co",
        canonical.to_string(), "Parsed canonical PURL should format as the same string",
    );
    let parsed = GenericPurl::<
        String,
    >::from_str(
            "pkg:huggingface/microsoft/deberta-v3-base@559062ad13d311b87b2c455e67dcd5f1c8f65111?repository_url=https://hub-ci.huggingface.co",
        )
        .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, ParseError>::Ok(
        GenericPurl::builder("huggingface".to_owned(), "deberta-v3-base")
            .with_namespace("microsoft")
            .with_version("559062ad13d311b87b2c455e67dcd5f1c8f65111"),
    )
    .and_then(|builder| {
        Ok(builder.with_qualifier("repository_url", "https://hub-ci.huggingface.co")?)
    })
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// MLflow model tracked in Azure ML (case sensitive)
fn m_lflow_model_tracked_in_azure_ml_case_sensitive_() {
    let canonical = GenericPurl::<
        String,
    >::from_str(
            "pkg:mlflow/CreditFraud@3?repository_url=https://westus2.api.azureml.ms/mlflow/v1.0/subscriptions/a50f2011-fab8-4164-af23-c62881ef8c95/resourceGroups/TestResourceGroup/providers/Microsoft.MachineLearningServices/workspaces/TestWorkspace",
        )
        .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:mlflow/CreditFraud@3?repository_url=https://westus2.api.azureml.ms/mlflow/v1.0/subscriptions/a50f2011-fab8-4164-af23-c62881ef8c95/resourceGroups/TestResourceGroup/providers/Microsoft.MachineLearningServices/workspaces/TestWorkspace",
        canonical.to_string(), "Parsed canonical PURL should format as the same string",
    );
    let parsed = GenericPurl::<
        String,
    >::from_str(
            "pkg:mlflow/CreditFraud@3?repository_url=https://westus2.api.azureml.ms/mlflow/v1.0/subscriptions/a50f2011-fab8-4164-af23-c62881ef8c95/resourceGroups/TestResourceGroup/providers/Microsoft.MachineLearningServices/workspaces/TestWorkspace",
        )
        .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<
        _,
        ParseError,
    >::Ok(GenericPurl::builder("mlflow".to_owned(), "CreditFraud").with_version("3"))
        .and_then(|builder| Ok(
            builder
                .with_qualifier(
                    "repository_url",
                    "https://westus2.api.azureml.ms/mlflow/v1.0/subscriptions/a50f2011-fab8-4164-af23-c62881ef8c95/resourceGroups/TestResourceGroup/providers/Microsoft.MachineLearningServices/workspaces/TestWorkspace",
                )?,
        ))
        .and_then(|builder| builder.build())
        .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// MLflow model with unique identifiers
fn m_lflow_model_with_unique_identifiers() {
    let canonical = GenericPurl::<
        String,
    >::from_str(
            "pkg:mlflow/trafficsigns@10?model_uuid=36233173b22f4c89b451f1228d700d49&repository_url=https://adb-5245952564735461.0.azuredatabricks.net/api/2.0/mlflow&run_id=410a3121-2709-4f88-98dd-dba0ef056b0a",
        )
        .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:mlflow/trafficsigns@10?model_uuid=36233173b22f4c89b451f1228d700d49&repository_url=https://adb-5245952564735461.0.azuredatabricks.net/api/2.0/mlflow&run_id=410a3121-2709-4f88-98dd-dba0ef056b0a",
        canonical.to_string(), "Parsed canonical PURL should format as the same string",
    );
    let parsed = GenericPurl::<
        String,
    >::from_str(
            "pkg:mlflow/trafficsigns@10?model_uuid=36233173b22f4c89b451f1228d700d49&run_id=410a3121-2709-4f88-98dd-dba0ef056b0a&repository_url=https://adb-5245952564735461.0.azuredatabricks.net/api/2.0/mlflow",
        )
        .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, ParseError>::Ok(
        GenericPurl::builder("mlflow".to_owned(), "trafficsigns").with_version("10"),
    )
    .and_then(|builder| {
        Ok(builder.with_qualifier("model_uuid", "36233173b22f4c89b451f1228d700d49")?)
    })
    .and_then(|builder| {
        Ok(builder.with_qualifier(
            "repository_url",
            "https://adb-5245952564735461.0.azuredatabricks.net/api/2.0/mlflow",
        )?)
    })
    .and_then(|builder| {
        Ok(builder.with_qualifier("run_id", "410a3121-2709-4f88-98dd-dba0ef056b0a")?)
    })
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// cpan distribution name are case sensitive
fn cpan_distribution_name_are_case_sensitive() {
    let canonical = GenericPurl::<String>::from_str("pkg:cpan/DROLSKY/DateTime@1.55")
        .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:cpan/DROLSKY/DateTime@1.55",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = GenericPurl::<String>::from_str("pkg:cpan/DROLSKY/DateTime@1.55")
        .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, ParseError>::Ok(
        GenericPurl::builder("cpan".to_owned(), "DateTime")
            .with_namespace("DROLSKY")
            .with_version("1.55"),
    )
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// cpan module name are case sensitive
fn cpan_module_name_are_case_sensitive() {
    let canonical = GenericPurl::<String>::from_str("pkg:cpan/URI::PackageURL@2.11")
        .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:cpan/URI::PackageURL@2.11",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = GenericPurl::<String>::from_str("pkg:cpan/URI::PackageURL@2.11")
        .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, ParseError>::Ok(
        GenericPurl::builder("cpan".to_owned(), "URI::PackageURL").with_version("2.11"),
    )
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// cpan valid module name
fn cpan_valid_module_name() {
    let canonical = GenericPurl::<String>::from_str("pkg:cpan/DateTime@1.55")
        .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:cpan/DateTime@1.55",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed =
        GenericPurl::<String>::from_str("pkg:cpan/DateTime@1.55").expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, ParseError>::Ok(
        GenericPurl::builder("cpan".to_owned(), "DateTime").with_version("1.55"),
    )
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// cpan valid module name without version
fn cpan_valid_module_name_without_version() {
    let canonical =
        GenericPurl::<String>::from_str("pkg:cpan/URI").expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:cpan/URI",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = GenericPurl::<String>::from_str("pkg:cpan/URI").expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, ParseError>::Ok(GenericPurl::builder("cpan".to_owned(), "URI"))
        .and_then(|builder| builder.build())
        .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// ensure namespace allows multiple segments
fn ensure_namespace_allows_multiple_segments() {
    let canonical = GenericPurl::<String>::from_str("pkg:bintray/apache/couchdb/couchdb-mac@2.3.0")
        .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:bintray/apache/couchdb/couchdb-mac@2.3.0",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = GenericPurl::<String>::from_str("pkg:bintray/apache/couchdb/couchdb-mac@2.3.0")
        .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, ParseError>::Ok(
        GenericPurl::builder("bintray".to_owned(), "couchdb-mac")
            .with_namespace("apache/couchdb")
            .with_version("2.3.0"),
    )
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// check for invalid character in type
fn check_for_invalid_character_in_type() {
    assert!(
        GenericPurl::<String>::from_str("pkg:n&g?inx/nginx@0.8.9").is_err(),
        "Invalid PURL should not build from parts"
    );
}
#[test]
/// check for type that starts with number
fn check_for_type_that_starts_with_number() {
    assert!(
        GenericPurl::<String>::from_str("pkg:3nginx/nginx@0.8.9").is_err(),
        "Invalid PURL should not build from parts"
    );
}
#[test]
/// check for colon in type
fn check_for_colon_in_type() {
    assert!(
        GenericPurl::<String>::from_str("pkg:nginx:a/nginx@0.8.9").is_err(),
        "Invalid PURL should not build from parts"
    );
}
#[test]
/// valid go purl with uppercase in namespace
fn valid_go_purl_with_uppercase_in_namespace() {
    let canonical = Purl::from_str("pkg:golang/github.com/GoogleCloudPlatform/cloud-sql-proxy/v2")
        .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:golang/github.com/GoogleCloudPlatform/cloud-sql-proxy/v2",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = Purl::from_str("pkg:golang/github.com/GoogleCloudPlatform/cloud-sql-proxy/v2")
        .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(
        Purl::builder(PackageType::Golang, "v2")
            .with_namespace("github.com/GoogleCloudPlatform/cloud-sql-proxy"),
    )
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// valid go purl with uppercase in name
fn valid_go_purl_with_uppercase_in_name() {
    let canonical =
        Purl::from_str("pkg:golang/example.com/A").expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:golang/example.com/A",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = Purl::from_str("pkg:golang/example.com/A").expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(
        Purl::builder(PackageType::Golang, "A").with_namespace("example.com"),
    )
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// valid go purl without namespace
fn valid_go_purl_without_namespace() {
    let canonical = Purl::from_str("pkg:golang/v.io").expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:golang/v.io",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = Purl::from_str("pkg:golang/v.io").expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(Purl::builder(PackageType::Golang, "v.io"))
        .and_then(|builder| builder.build())
        .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// valid npm purl with uppercase in name
fn valid_npm_purl_with_uppercase_in_name() {
    let canonical = Purl::from_str("pkg:npm/parseUri").expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:npm/parseUri",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = Purl::from_str("pkg:npm/parseUri").expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(Purl::builder(PackageType::Npm, "parseUri"))
        .and_then(|builder| builder.build())
        .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// valid cargo purl with uppercase in name
fn valid_cargo_purl_with_uppercase_in_name() {
    let canonical = Purl::from_str("pkg:cargo/Inflector").expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:cargo/Inflector",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = Purl::from_str("pkg:cargo/Inflector").expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(Purl::builder(PackageType::Cargo, "Inflector"))
        .and_then(|builder| builder.build())
        .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// non-canonical nuget purl with uppercase in name
fn non_canonical_nuget_purl_with_uppercase_in_name() {
    let canonical =
        Purl::from_str("pkg:nuget/newtonsoft.json").expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:nuget/newtonsoft.json",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = Purl::from_str("pkg:nuget/Newtonsoft.Json").expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts =
        Result::<_, PackageError>::Ok(Purl::builder(PackageType::NuGet, "newtonsoft.json"))
            .and_then(|builder| builder.build())
            .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// non-canonical pypi purl with uppercase in name
fn non_canonical_pypi_purl_with_uppercase_in_name() {
    let canonical = Purl::from_str("pkg:pypi/pytest").expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:pypi/pytest",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = Purl::from_str("pkg:pypi/PyTest").expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(Purl::builder(PackageType::PyPI, "pytest"))
        .and_then(|builder| builder.build())
        .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// non-canonical pypi purl with specials in name
fn non_canonical_pypi_purl_with_specials_in_name() {
    let canonical = Purl::from_str("pkg:pypi/-special-name-").expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:pypi/-special-name-",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed =
        Purl::from_str("pkg:pypi/_-.-_special_-.-_name_-.-_").expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts =
        Result::<_, PackageError>::Ok(Purl::builder(PackageType::PyPI, "-special-name-"))
            .and_then(|builder| builder.build())
            .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// invalid maven purl without namespace
fn invalid_maven_purl_without_namespace() {
    assert!(
        Purl::from_str("pkg:maven/invalid").is_err(),
        "Invalid PURL should not build from parts"
    );
}
#[test]
/// invalid maven purl without namespace
fn invalid_maven_purl_without_namespace_from_parts() {
    assert!(
        Result::<_, PackageError>::Ok(Purl::builder(PackageType::Maven, "invalid"))
            .and_then(|builder| builder.build())
            .is_err(),
        "Invalid PURL should not parse"
    );
}
#[test]
/// plus signs and spaces
fn plus_signs_and_spaces() {
    let canonical =
        Purl::from_str("pkg:cargo/example?repository_url=https://example.com/a%20b%2Bc/")
            .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:cargo/example?repository_url=https://example.com/a%20b%2Bc/",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = Purl::from_str("pkg:cargo/example?repository_url=https://example.com/a%20b+c/")
        .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, PackageError>::Ok(Purl::builder(PackageType::Cargo, "example"))
        .and_then(|builder| {
            Ok(builder.with_qualifier("repository_url", "https://example.com/a b+c/")?)
        })
        .and_then(|builder| builder.build())
        .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// percent signs are properly encoded and decoded
fn percent_signs_are_properly_encoded_and_decoded() {
    let canonical = GenericPurl::<String>::from_str(
        "pkg:generic/100%25/100%25@100%25?repository_url=https://example.com/100%2525/#100%25",
    )
    .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:generic/100%25/100%25@100%25?repository_url=https://example.com/100%2525/#100%25",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = GenericPurl::<String>::from_str(
        "pkg:generic/100%25/100%25@100%25?repository_url=https://example.com/100%2525/#100%25",
    )
    .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, ParseError>::Ok(
        GenericPurl::builder("generic".to_owned(), "100%")
            .with_namespace("100%")
            .with_version("100%"),
    )
    .and_then(
        |builder| Ok(builder.with_qualifier("repository_url", "https://example.com/100%25/")?),
    )
    .map(|builder| builder.with_subpath("100%"))
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
#[test]
/// version encoding
fn version_encoding() {
    let canonical = GenericPurl::<String>::from_str("pkg:generic/name@a%23/b%3F/c%40")
        .expect("Canonical PURL should parse");
    assert_eq!(
        "pkg:generic/name@a%23/b%3F/c%40",
        canonical.to_string(),
        "Parsed canonical PURL should format as the same string",
    );
    let parsed = GenericPurl::<String>::from_str("pkg:generic/name@a%23%2Fb%3F%2Fc%40")
        .expect("Test PURL should parse");
    assert_eq!(canonical, parsed, "Test PURL should parse as canonical PURL");
    let from_parts = Result::<_, ParseError>::Ok(
        GenericPurl::builder("generic".to_owned(), "name").with_version("a#/b?/c@"),
    )
    .and_then(|builder| builder.build())
    .expect("Constructing valid PURL from parts should succeed");
    assert_eq!(
        canonical, from_parts,
        "Constructing PURL from parts should result in canonical PURL"
    );
}
