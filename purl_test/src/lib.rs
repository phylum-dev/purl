// This file is autogenerated by generate_tests.rs.
// Use `cargo xtask codegen` to regenerate it.
#![cfg(test)]

use std::collections::HashMap;
use std::str::FromStr;

use purl::{GenericPurl, PackageError, PackageType, Purl};
#[test]
/// valid maven purl
fn valid_maven_purl() {
    let parsed = match Purl::from_str("pkg:maven/org.apache.commons/io@1.3.4") {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:maven/org.apache.commons/io@1.3.4", error
            )
        },
    };
    assert_eq!(&PackageType::Maven, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("org.apache.commons"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("io", parsed.name(), "Incorrect name");
    assert_eq!(Some("1.3.4"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:maven/org.apache.commons/io@1.3.4", canonicalized,
        "Incorrect string representation"
    );
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse canonical purl {:?}: {}",
                "pkg:maven/org.apache.commons/io@1.3.4", error
            )
        },
    };
    assert_eq!(
        &PackageType::Maven,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(
        Some("org.apache.commons"),
        parsed_canonical.namespace(),
        "Incorrect namespace for canonicalized PURL"
    );
    assert_eq!("io", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(
        Some("1.3.4"),
        parsed_canonical.version(),
        "Incorrect version for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// basic valid maven purl without version
fn basic_valid_maven_purl_without_version() {
    let parsed = match Purl::from_str("pkg:maven/org.apache.commons/io") {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse valid purl {:?}: {}", "pkg:maven/org.apache.commons/io", error)
        },
    };
    assert_eq!(&PackageType::Maven, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("org.apache.commons"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("io", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!("pkg:maven/org.apache.commons/io", canonicalized, "Incorrect string representation");
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse canonical purl {:?}: {}",
                "pkg:maven/org.apache.commons/io", error
            )
        },
    };
    assert_eq!(
        &PackageType::Maven,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(
        Some("org.apache.commons"),
        parsed_canonical.namespace(),
        "Incorrect namespace for canonicalized PURL"
    );
    assert_eq!("io", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(None, parsed_canonical.version(), "Incorrect version for canonicalized PURL");
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// valid go purl without version and with subpath
fn valid_go_purl_without_version_and_with_subpath() {
    let parsed = match Purl::from_str(
        "pkg:GOLANG/google.golang.org/genproto#/googleapis/api/annotations/",
    ) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:GOLANG/google.golang.org/genproto#/googleapis/api/annotations/", error
            )
        },
    };
    assert_eq!(&PackageType::Golang, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("google.golang.org"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("genproto", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(Some("googleapis/api/annotations"), parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:golang/google.golang.org/genproto#googleapis/api/annotations", canonicalized,
        "Incorrect string representation"
    );
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse canonical purl {:?}: {}",
                "pkg:GOLANG/google.golang.org/genproto#/googleapis/api/annotations/", error
            )
        },
    };
    assert_eq!(
        &PackageType::Golang,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(
        Some("google.golang.org"),
        parsed_canonical.namespace(),
        "Incorrect namespace for canonicalized PURL"
    );
    assert_eq!("genproto", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(None, parsed_canonical.version(), "Incorrect version for canonicalized PURL");
    assert_eq!(
        Some("googleapis/api/annotations"),
        parsed_canonical.subpath(),
        "Incorrect subpath for canonicalized PURL"
    );
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// valid go purl with version and subpath
fn valid_go_purl_with_version_and_subpath() {
    let parsed = match Purl::from_str(
        "pkg:GOLANG/google.golang.org/genproto@abcdedf#/googleapis/api/annotations/",
    ) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:GOLANG/google.golang.org/genproto@abcdedf#/googleapis/api/annotations/", error
            )
        },
    };
    assert_eq!(&PackageType::Golang, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("google.golang.org"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("genproto", parsed.name(), "Incorrect name");
    assert_eq!(Some("abcdedf"), parsed.version(), "Incorrect version");
    assert_eq!(Some("googleapis/api/annotations"), parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:golang/google.golang.org/genproto@abcdedf#googleapis/api/annotations", canonicalized,
        "Incorrect string representation"
    );
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse canonical purl {:?}: {}",
                "pkg:GOLANG/google.golang.org/genproto@abcdedf#/googleapis/api/annotations/", error
            )
        },
    };
    assert_eq!(
        &PackageType::Golang,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(
        Some("google.golang.org"),
        parsed_canonical.namespace(),
        "Incorrect namespace for canonicalized PURL"
    );
    assert_eq!("genproto", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(
        Some("abcdedf"),
        parsed_canonical.version(),
        "Incorrect version for canonicalized PURL"
    );
    assert_eq!(
        Some("googleapis/api/annotations"),
        parsed_canonical.subpath(),
        "Incorrect subpath for canonicalized PURL"
    );
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// debian can use qualifiers
fn debian_can_use_qualifiers() {
    let parsed = {
        assert!(
            matches!(
                Purl::from_str("pkg:deb/debian/curl@7.50.3-1?arch=i386&distro=jessie"),
                Err(PackageError::UnsupportedType)
            ),
            "Type {} is not supported",
            "deb"
        );
        match GenericPurl::<String>::from_str(
            "pkg:deb/debian/curl@7.50.3-1?arch=i386&distro=jessie",
        ) {
            Ok(purl) => purl,
            Err(error) => {
                panic!(
                    "Failed to parse valid purl {:?}: {}",
                    "pkg:deb/debian/curl@7.50.3-1?arch=i386&distro=jessie", error
                )
            },
        }
    };
    assert_eq!("deb", parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("debian"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("curl", parsed.name(), "Incorrect name");
    assert_eq!(Some("7.50.3-1"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        [("arch", "i386"), ("distro", "jessie")].into_iter().collect::<HashMap<&str, &str>>(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:deb/debian/curl@7.50.3-1?arch=i386&distro=jessie", canonicalized,
        "Incorrect string representation"
    );
    let parsed_canonical = match GenericPurl::<String>::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:deb/debian/curl@7.50.3-1?arch=i386&distro=jessie", error
            )
        },
    };
    assert_eq!(
        "deb",
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(
        Some("debian"),
        parsed_canonical.namespace(),
        "Incorrect namespace for canonicalized PURL"
    );
    assert_eq!("curl", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(
        Some("7.50.3-1"),
        parsed_canonical.version(),
        "Incorrect version for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        [("arch", "i386"), ("distro", "jessie")].into_iter().collect::<HashMap<&str, &str>>(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// docker uses qualifiers and hash image id as versions
fn docker_uses_qualifiers_and_hash_image_id_as_versions() {
    let parsed = {
        assert!(
            matches!(
                Purl::from_str(
                    "pkg:docker/customer/dockerimage@sha256:244fd47e07d1004f0aed9c?\
                     repository_url=gcr.io"
                ),
                Err(PackageError::UnsupportedType)
            ),
            "Type {} is not supported",
            "docker"
        );
        match GenericPurl::<String>::from_str(
            "pkg:docker/customer/dockerimage@sha256:244fd47e07d1004f0aed9c?repository_url=gcr.io",
        ) {
            Ok(purl) => purl,
            Err(error) => {
                panic!(
                    "Failed to parse valid purl {:?}: {}",
                    "pkg:docker/customer/dockerimage@sha256:244fd47e07d1004f0aed9c?\
                     repository_url=gcr.io",
                    error
                )
            },
        }
    };
    assert_eq!("docker", parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("customer"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("dockerimage", parsed.name(), "Incorrect name");
    assert_eq!(Some("sha256:244fd47e07d1004f0aed9c"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        [("repository_url", "gcr.io")].into_iter().collect::<HashMap<&str, &str>>(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:docker/customer/dockerimage@sha256:244fd47e07d1004f0aed9c?repository_url=gcr.io",
        canonicalized,
        "Incorrect string representation"
    );
    let parsed_canonical = match GenericPurl::<String>::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:docker/customer/dockerimage@sha256:244fd47e07d1004f0aed9c?repository_url=gcr.\
                 io",
                error
            )
        },
    };
    assert_eq!(
        "docker",
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(
        Some("customer"),
        parsed_canonical.namespace(),
        "Incorrect namespace for canonicalized PURL"
    );
    assert_eq!("dockerimage", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(
        Some("sha256:244fd47e07d1004f0aed9c"),
        parsed_canonical.version(),
        "Incorrect version for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        [("repository_url", "gcr.io")].into_iter().collect::<HashMap<&str, &str>>(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// Java gem can use a qualifier
fn java_gem_can_use_a_qualifier() {
    let parsed = match Purl::from_str("pkg:gem/jruby-launcher@1.1.2?Platform=java") {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:gem/jruby-launcher@1.1.2?Platform=java", error
            )
        },
    };
    assert_eq!(&PackageType::Gem, parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("jruby-launcher", parsed.name(), "Incorrect name");
    assert_eq!(Some("1.1.2"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        [("platform", "java")].into_iter().collect::<HashMap<&str, &str>>(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:gem/jruby-launcher@1.1.2?platform=java", canonicalized,
        "Incorrect string representation"
    );
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse canonical purl {:?}: {}",
                "pkg:gem/jruby-launcher@1.1.2?Platform=java", error
            )
        },
    };
    assert_eq!(
        &PackageType::Gem,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.namespace(), "Incorrect namespace for canonicalized PURL");
    assert_eq!("jruby-launcher", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(
        Some("1.1.2"),
        parsed_canonical.version(),
        "Incorrect version for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        [("platform", "java")].into_iter().collect::<HashMap<&str, &str>>(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// maven often uses qualifiers
fn maven_often_uses_qualifiers() {
    let parsed = match Purl::from_str(
        "pkg:Maven/org.apache.xmlgraphics/batik-anim@1.9.1?classifier=sources&repositorY_url=repo.\
         spring.io/release",
    ) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:Maven/org.apache.xmlgraphics/batik-anim@1.9.1?classifier=sources&\
                 repositorY_url=repo.spring.io/release",
                error
            )
        },
    };
    assert_eq!(&PackageType::Maven, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("org.apache.xmlgraphics"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("batik-anim", parsed.name(), "Incorrect name");
    assert_eq!(Some("1.9.1"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        [("classifier", "sources"), ("repository_url", "repo.spring.io/release")]
            .into_iter()
            .collect::<HashMap<&str, &str>>(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:maven/org.apache.xmlgraphics/batik-anim@1.9.1?classifier=sources&repository_url=repo.\
         spring.io/release",
        canonicalized,
        "Incorrect string representation"
    );
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse canonical purl {:?}: {}",
                "pkg:Maven/org.apache.xmlgraphics/batik-anim@1.9.1?classifier=sources&\
                 repositorY_url=repo.spring.io/release",
                error
            )
        },
    };
    assert_eq!(
        &PackageType::Maven,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(
        Some("org.apache.xmlgraphics"),
        parsed_canonical.namespace(),
        "Incorrect namespace for canonicalized PURL"
    );
    assert_eq!("batik-anim", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(
        Some("1.9.1"),
        parsed_canonical.version(),
        "Incorrect version for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        [("classifier", "sources"), ("repository_url", "repo.spring.io/release")]
            .into_iter()
            .collect::<HashMap<&str, &str>>(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// maven pom reference
fn maven_pom_reference() {
    let parsed = match Purl::from_str(
        "pkg:Maven/org.apache.xmlgraphics/batik-anim@1.9.1?extension=pom&repositorY_url=repo.\
         spring.io/release",
    ) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:Maven/org.apache.xmlgraphics/batik-anim@1.9.1?extension=pom&\
                 repositorY_url=repo.spring.io/release",
                error
            )
        },
    };
    assert_eq!(&PackageType::Maven, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("org.apache.xmlgraphics"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("batik-anim", parsed.name(), "Incorrect name");
    assert_eq!(Some("1.9.1"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        [("extension", "pom"), ("repository_url", "repo.spring.io/release")]
            .into_iter()
            .collect::<HashMap<&str, &str>>(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:maven/org.apache.xmlgraphics/batik-anim@1.9.1?extension=pom&repository_url=repo.\
         spring.io/release",
        canonicalized,
        "Incorrect string representation"
    );
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse canonical purl {:?}: {}",
                "pkg:Maven/org.apache.xmlgraphics/batik-anim@1.9.1?extension=pom&\
                 repositorY_url=repo.spring.io/release",
                error
            )
        },
    };
    assert_eq!(
        &PackageType::Maven,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(
        Some("org.apache.xmlgraphics"),
        parsed_canonical.namespace(),
        "Incorrect namespace for canonicalized PURL"
    );
    assert_eq!("batik-anim", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(
        Some("1.9.1"),
        parsed_canonical.version(),
        "Incorrect version for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        [("extension", "pom"), ("repository_url", "repo.spring.io/release")]
            .into_iter()
            .collect::<HashMap<&str, &str>>(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// maven can come with a type qualifier
fn maven_can_come_with_a_type_qualifier() {
    let parsed =
        match Purl::from_str("pkg:Maven/net.sf.jacob-project/jacob@1.14.3?classifier=x86&type=dll")
        {
            Ok(purl) => purl,
            Err(error) => {
                panic!(
                    "Failed to parse valid purl {:?}: {}",
                    "pkg:Maven/net.sf.jacob-project/jacob@1.14.3?classifier=x86&type=dll", error
                )
            },
        };
    assert_eq!(&PackageType::Maven, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("net.sf.jacob-project"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("jacob", parsed.name(), "Incorrect name");
    assert_eq!(Some("1.14.3"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        [("classifier", "x86"), ("type", "dll")].into_iter().collect::<HashMap<&str, &str>>(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:maven/net.sf.jacob-project/jacob@1.14.3?classifier=x86&type=dll", canonicalized,
        "Incorrect string representation"
    );
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse canonical purl {:?}: {}",
                "pkg:Maven/net.sf.jacob-project/jacob@1.14.3?classifier=x86&type=dll", error
            )
        },
    };
    assert_eq!(
        &PackageType::Maven,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(
        Some("net.sf.jacob-project"),
        parsed_canonical.namespace(),
        "Incorrect namespace for canonicalized PURL"
    );
    assert_eq!("jacob", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(
        Some("1.14.3"),
        parsed_canonical.version(),
        "Incorrect version for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        [("classifier", "x86"), ("type", "dll")].into_iter().collect::<HashMap<&str, &str>>(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// npm can be scoped
fn npm_can_be_scoped() {
    let parsed = match Purl::from_str("pkg:npm/%40angular/animation@12.3.1") {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:npm/%40angular/animation@12.3.1", error
            )
        },
    };
    assert_eq!(&PackageType::Npm, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("@angular"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("animation", parsed.name(), "Incorrect name");
    assert_eq!(Some("12.3.1"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:npm/%40angular/animation@12.3.1", canonicalized,
        "Incorrect string representation"
    );
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse canonical purl {:?}: {}",
                "pkg:npm/%40angular/animation@12.3.1", error
            )
        },
    };
    assert_eq!(
        &PackageType::Npm,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(
        Some("@angular"),
        parsed_canonical.namespace(),
        "Incorrect namespace for canonicalized PURL"
    );
    assert_eq!("animation", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(
        Some("12.3.1"),
        parsed_canonical.version(),
        "Incorrect version for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// pypi names have special rules and not case sensitive
fn pypi_names_have_special_rules_and_not_case_sensitive() {
    let parsed = match Purl::from_str("pkg:PYPI/Django_package@1.11.1.dev1") {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:PYPI/Django_package@1.11.1.dev1", error
            )
        },
    };
    assert_eq!(&PackageType::PyPI, parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("django-package", parsed.name(), "Incorrect name");
    assert_eq!(Some("1.11.1.dev1"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:pypi/django-package@1.11.1.dev1", canonicalized,
        "Incorrect string representation"
    );
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse canonical purl {:?}: {}",
                "pkg:PYPI/Django_package@1.11.1.dev1", error
            )
        },
    };
    assert_eq!(
        &PackageType::PyPI,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.namespace(), "Incorrect namespace for canonicalized PURL");
    assert_eq!("django-package", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(
        Some("1.11.1.dev1"),
        parsed_canonical.version(),
        "Incorrect version for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// rpm often use qualifiers
fn rpm_often_use_qualifiers() {
    let parsed = {
        assert!(
            matches!(
                Purl::from_str("pkg:Rpm/fedora/curl@7.50.3-1.fc25?Arch=i386&Distro=fedora-25"),
                Err(PackageError::UnsupportedType)
            ),
            "Type {} is not supported",
            "rpm"
        );
        match GenericPurl::<String>::from_str(
            "pkg:Rpm/fedora/curl@7.50.3-1.fc25?Arch=i386&Distro=fedora-25",
        ) {
            Ok(purl) => purl,
            Err(error) => {
                panic!(
                    "Failed to parse valid purl {:?}: {}",
                    "pkg:Rpm/fedora/curl@7.50.3-1.fc25?Arch=i386&Distro=fedora-25", error
                )
            },
        }
    };
    assert_eq!("rpm", parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("fedora"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("curl", parsed.name(), "Incorrect name");
    assert_eq!(Some("7.50.3-1.fc25"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        [("arch", "i386"), ("distro", "fedora-25")].into_iter().collect::<HashMap<&str, &str>>(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:rpm/fedora/curl@7.50.3-1.fc25?arch=i386&distro=fedora-25", canonicalized,
        "Incorrect string representation"
    );
    let parsed_canonical = match GenericPurl::<String>::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:Rpm/fedora/curl@7.50.3-1.fc25?Arch=i386&Distro=fedora-25", error
            )
        },
    };
    assert_eq!(
        "rpm",
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(
        Some("fedora"),
        parsed_canonical.namespace(),
        "Incorrect namespace for canonicalized PURL"
    );
    assert_eq!("curl", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(
        Some("7.50.3-1.fc25"),
        parsed_canonical.version(),
        "Incorrect version for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        [("arch", "i386"), ("distro", "fedora-25")].into_iter().collect::<HashMap<&str, &str>>(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// a scheme is always required
fn a_scheme_is_always_required() {
    assert!(
        Purl::from_str("EnterpriseLibrary.Common@6.0.1304").is_err(),
        "{}",
        "a scheme is always required"
    );
}
#[test]
/// a type is always required
fn a_type_is_always_required() {
    assert!(
        Purl::from_str("pkg:EnterpriseLibrary.Common@6.0.1304").is_err(),
        "{}",
        "a type is always required"
    );
}
#[test]
/// a name is required
fn a_name_is_required() {
    assert!(Purl::from_str("pkg:maven/@1.3.4").is_err(), "{}", "a name is required");
}
#[test]
/// slash / after scheme is not significant
fn slash_after_scheme_is_not_significant() {
    let parsed = match Purl::from_str("pkg:/maven/org.apache.commons/io") {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse valid purl {:?}: {}", "pkg:/maven/org.apache.commons/io", error)
        },
    };
    assert_eq!(&PackageType::Maven, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("org.apache.commons"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("io", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!("pkg:maven/org.apache.commons/io", canonicalized, "Incorrect string representation");
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse canonical purl {:?}: {}",
                "pkg:/maven/org.apache.commons/io", error
            )
        },
    };
    assert_eq!(
        &PackageType::Maven,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(
        Some("org.apache.commons"),
        parsed_canonical.namespace(),
        "Incorrect namespace for canonicalized PURL"
    );
    assert_eq!("io", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(None, parsed_canonical.version(), "Incorrect version for canonicalized PURL");
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// double slash // after scheme is not significant
fn double_slash_after_scheme_is_not_significant() {
    let parsed = match Purl::from_str("pkg://maven/org.apache.commons/io") {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg://maven/org.apache.commons/io", error
            )
        },
    };
    assert_eq!(&PackageType::Maven, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("org.apache.commons"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("io", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!("pkg:maven/org.apache.commons/io", canonicalized, "Incorrect string representation");
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse canonical purl {:?}: {}",
                "pkg://maven/org.apache.commons/io", error
            )
        },
    };
    assert_eq!(
        &PackageType::Maven,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(
        Some("org.apache.commons"),
        parsed_canonical.namespace(),
        "Incorrect namespace for canonicalized PURL"
    );
    assert_eq!("io", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(None, parsed_canonical.version(), "Incorrect version for canonicalized PURL");
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// slash /// after type  is not significant
fn slash_after_type_is_not_significant() {
    let parsed = match Purl::from_str("pkg:///maven/org.apache.commons/io") {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:///maven/org.apache.commons/io", error
            )
        },
    };
    assert_eq!(&PackageType::Maven, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("org.apache.commons"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("io", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!("pkg:maven/org.apache.commons/io", canonicalized, "Incorrect string representation");
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse canonical purl {:?}: {}",
                "pkg:///maven/org.apache.commons/io", error
            )
        },
    };
    assert_eq!(
        &PackageType::Maven,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(
        Some("org.apache.commons"),
        parsed_canonical.namespace(),
        "Incorrect namespace for canonicalized PURL"
    );
    assert_eq!("io", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(None, parsed_canonical.version(), "Incorrect version for canonicalized PURL");
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// valid maven purl with case sensitive namespace and name
fn valid_maven_purl_with_case_sensitive_namespace_and_name() {
    let parsed = match Purl::from_str("pkg:maven/HTTPClient/HTTPClient@0.3-3") {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:maven/HTTPClient/HTTPClient@0.3-3", error
            )
        },
    };
    assert_eq!(&PackageType::Maven, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("HTTPClient"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("HTTPClient", parsed.name(), "Incorrect name");
    assert_eq!(Some("0.3-3"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:maven/HTTPClient/HTTPClient@0.3-3", canonicalized,
        "Incorrect string representation"
    );
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse canonical purl {:?}: {}",
                "pkg:maven/HTTPClient/HTTPClient@0.3-3", error
            )
        },
    };
    assert_eq!(
        &PackageType::Maven,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(
        Some("HTTPClient"),
        parsed_canonical.namespace(),
        "Incorrect namespace for canonicalized PURL"
    );
    assert_eq!("HTTPClient", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(
        Some("0.3-3"),
        parsed_canonical.version(),
        "Incorrect version for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// valid maven purl containing a space in the version and qualifier
fn valid_maven_purl_containing_a_space_in_the_version_and_qualifier() {
    let parsed = match Purl::from_str("pkg:maven/mygroup/myartifact@1.0.0%20Final?mykey=my%20value")
    {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:maven/mygroup/myartifact@1.0.0%20Final?mykey=my%20value", error
            )
        },
    };
    assert_eq!(&PackageType::Maven, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("mygroup"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("myartifact", parsed.name(), "Incorrect name");
    assert_eq!(Some("1.0.0 Final"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        [("mykey", "my value")].into_iter().collect::<HashMap<&str, &str>>(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:maven/mygroup/myartifact@1.0.0%20Final?mykey=my%20value", canonicalized,
        "Incorrect string representation"
    );
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse canonical purl {:?}: {}",
                "pkg:maven/mygroup/myartifact@1.0.0%20Final?mykey=my%20value", error
            )
        },
    };
    assert_eq!(
        &PackageType::Maven,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(
        Some("mygroup"),
        parsed_canonical.namespace(),
        "Incorrect namespace for canonicalized PURL"
    );
    assert_eq!("myartifact", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(
        Some("1.0.0 Final"),
        parsed_canonical.version(),
        "Incorrect version for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        [("mykey", "my value")].into_iter().collect::<HashMap<&str, &str>>(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// checks for invalid qualifier keys
fn checks_for_invalid_qualifier_keys() {
    assert!(
        Purl::from_str("pkg:npm/myartifact@1.0.0?in%20production=true").is_err(),
        "{}",
        "checks for invalid qualifier keys"
    );
}
#[test]
/// valid conan purl
fn valid_conan_purl() {
    let parsed = {
        assert!(
            matches!(Purl::from_str("pkg:conan/cctz@2.3"), Err(PackageError::UnsupportedType)),
            "Type {} is not supported",
            "conan"
        );
        match GenericPurl::<String>::from_str("pkg:conan/cctz@2.3") {
            Ok(purl) => purl,
            Err(error) => {
                panic!("Failed to parse valid purl {:?}: {}", "pkg:conan/cctz@2.3", error)
            },
        }
    };
    assert_eq!("conan", parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("cctz", parsed.name(), "Incorrect name");
    assert_eq!(Some("2.3"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!("pkg:conan/cctz@2.3", canonicalized, "Incorrect string representation");
    let parsed_canonical = match GenericPurl::<String>::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse valid purl {:?}: {}", "pkg:conan/cctz@2.3", error)
        },
    };
    assert_eq!(
        "conan",
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.namespace(), "Incorrect namespace for canonicalized PURL");
    assert_eq!("cctz", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(Some("2.3"), parsed_canonical.version(), "Incorrect version for canonicalized PURL");
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// valid conan purl with namespace and qualifier channel
fn valid_conan_purl_with_namespace_and_qualifier_channel() {
    let parsed = {
        assert!(
            matches!(
                Purl::from_str("pkg:conan/bincrafters/cctz@2.3?channel=stable"),
                Err(PackageError::UnsupportedType)
            ),
            "Type {} is not supported",
            "conan"
        );
        match GenericPurl::<String>::from_str("pkg:conan/bincrafters/cctz@2.3?channel=stable") {
            Ok(purl) => purl,
            Err(error) => {
                panic!(
                    "Failed to parse valid purl {:?}: {}",
                    "pkg:conan/bincrafters/cctz@2.3?channel=stable", error
                )
            },
        }
    };
    assert_eq!("conan", parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("bincrafters"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("cctz", parsed.name(), "Incorrect name");
    assert_eq!(Some("2.3"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        [("channel", "stable")].into_iter().collect::<HashMap<&str, &str>>(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:conan/bincrafters/cctz@2.3?channel=stable", canonicalized,
        "Incorrect string representation"
    );
    let parsed_canonical = match GenericPurl::<String>::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:conan/bincrafters/cctz@2.3?channel=stable", error
            )
        },
    };
    assert_eq!(
        "conan",
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(
        Some("bincrafters"),
        parsed_canonical.namespace(),
        "Incorrect namespace for canonicalized PURL"
    );
    assert_eq!("cctz", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(Some("2.3"), parsed_canonical.version(), "Incorrect version for canonicalized PURL");
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        [("channel", "stable")].into_iter().collect::<HashMap<&str, &str>>(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// invalid conan purl only namespace
fn invalid_conan_purl_only_namespace() {
    assert!(
        Purl::from_str("pkg:conan/bincrafters/cctz@2.3").is_err(),
        "{}",
        "invalid conan purl only namespace"
    );
}
#[test]
/// invalid conan purl only channel qualifier
fn invalid_conan_purl_only_channel_qualifier() {
    assert!(
        Purl::from_str("pkg:conan/cctz@2.3?channel=stable").is_err(),
        "{}",
        "invalid conan purl only channel qualifier"
    );
}
#[test]
/// valid conda purl with qualifiers
fn valid_conda_purl_with_qualifiers() {
    let parsed = {
        assert!(
            matches!(
                Purl::from_str(
                    "pkg:conda/absl-py@0.4.1?build=py36h06a4308_0&channel=main&subdir=linux-64&\
                     type=tar.bz2"
                ),
                Err(PackageError::UnsupportedType)
            ),
            "Type {} is not supported",
            "conda"
        );
        match GenericPurl::<String>::from_str(
            "pkg:conda/absl-py@0.4.1?build=py36h06a4308_0&channel=main&subdir=linux-64&type=tar.\
             bz2",
        ) {
            Ok(purl) => purl,
            Err(error) => {
                panic!(
                    "Failed to parse valid purl {:?}: {}",
                    "pkg:conda/absl-py@0.4.1?build=py36h06a4308_0&channel=main&subdir=linux-64&\
                     type=tar.bz2",
                    error
                )
            },
        }
    };
    assert_eq!("conda", parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("absl-py", parsed.name(), "Incorrect name");
    assert_eq!(Some("0.4.1"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        [
            ("build", "py36h06a4308_0"),
            ("channel", "main"),
            ("subdir", "linux-64"),
            ("type", "tar.bz2")
        ]
        .into_iter()
        .collect::<HashMap<&str, &str>>(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:conda/absl-py@0.4.1?build=py36h06a4308_0&channel=main&subdir=linux-64&type=tar.bz2",
        canonicalized,
        "Incorrect string representation"
    );
    let parsed_canonical = match GenericPurl::<String>::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:conda/absl-py@0.4.1?build=py36h06a4308_0&channel=main&subdir=linux-64&\
                 type=tar.bz2",
                error
            )
        },
    };
    assert_eq!(
        "conda",
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.namespace(), "Incorrect namespace for canonicalized PURL");
    assert_eq!("absl-py", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(
        Some("0.4.1"),
        parsed_canonical.version(),
        "Incorrect version for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        [
            ("build", "py36h06a4308_0"),
            ("channel", "main"),
            ("subdir", "linux-64"),
            ("type", "tar.bz2")
        ]
        .into_iter()
        .collect::<HashMap<&str, &str>>(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// valid cran purl
fn valid_cran_purl() {
    let parsed = {
        assert!(
            matches!(Purl::from_str("pkg:cran/A3@0.9.1"), Err(PackageError::UnsupportedType)),
            "Type {} is not supported",
            "cran"
        );
        match GenericPurl::<String>::from_str("pkg:cran/A3@0.9.1") {
            Ok(purl) => purl,
            Err(error) => {
                panic!("Failed to parse valid purl {:?}: {}", "pkg:cran/A3@0.9.1", error)
            },
        }
    };
    assert_eq!("cran", parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("A3", parsed.name(), "Incorrect name");
    assert_eq!(Some("0.9.1"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!("pkg:cran/A3@0.9.1", canonicalized, "Incorrect string representation");
    let parsed_canonical = match GenericPurl::<String>::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse valid purl {:?}: {}", "pkg:cran/A3@0.9.1", error)
        },
    };
    assert_eq!(
        "cran",
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.namespace(), "Incorrect namespace for canonicalized PURL");
    assert_eq!("A3", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(
        Some("0.9.1"),
        parsed_canonical.version(),
        "Incorrect version for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// invalid cran purl without name
fn invalid_cran_purl_without_name() {
    assert!(Purl::from_str("pkg:cran/@0.9.1").is_err(), "{}", "invalid cran purl without name");
}
#[test]
/// invalid cran purl without version
fn invalid_cran_purl_without_version() {
    assert!(Purl::from_str("pkg:cran/A3").is_err(), "{}", "invalid cran purl without version");
}
#[test]
/// valid swift purl
fn valid_swift_purl() {
    let parsed = {
        assert!(
            matches!(
                Purl::from_str("pkg:swift/github.com/Alamofire/Alamofire@5.4.3"),
                Err(PackageError::UnsupportedType)
            ),
            "Type {} is not supported",
            "swift"
        );
        match GenericPurl::<String>::from_str("pkg:swift/github.com/Alamofire/Alamofire@5.4.3") {
            Ok(purl) => purl,
            Err(error) => {
                panic!(
                    "Failed to parse valid purl {:?}: {}",
                    "pkg:swift/github.com/Alamofire/Alamofire@5.4.3", error
                )
            },
        }
    };
    assert_eq!("swift", parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("github.com/Alamofire"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("Alamofire", parsed.name(), "Incorrect name");
    assert_eq!(Some("5.4.3"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:swift/github.com/Alamofire/Alamofire@5.4.3", canonicalized,
        "Incorrect string representation"
    );
    let parsed_canonical = match GenericPurl::<String>::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:swift/github.com/Alamofire/Alamofire@5.4.3", error
            )
        },
    };
    assert_eq!(
        "swift",
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(
        Some("github.com/Alamofire"),
        parsed_canonical.namespace(),
        "Incorrect namespace for canonicalized PURL"
    );
    assert_eq!("Alamofire", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(
        Some("5.4.3"),
        parsed_canonical.version(),
        "Incorrect version for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// invalid swift purl without namespace
fn invalid_swift_purl_without_namespace() {
    assert!(
        Purl::from_str("pkg:swift/Alamofire@5.4.3").is_err(),
        "{}",
        "invalid swift purl without namespace"
    );
}
#[test]
/// invalid swift purl without name
fn invalid_swift_purl_without_name() {
    assert!(
        Purl::from_str("pkg:swift/github.com/Alamofire/@5.4.3").is_err(),
        "{}",
        "invalid swift purl without name"
    );
}
#[test]
/// invalid swift purl without version
fn invalid_swift_purl_without_version() {
    assert!(
        Purl::from_str("pkg:swift/github.com/Alamofire/Alamofire").is_err(),
        "{}",
        "invalid swift purl without version"
    );
}
#[test]
/// valid hackage purl
fn valid_hackage_purl() {
    let parsed = {
        assert!(
            matches!(
                Purl::from_str("pkg:hackage/AC-HalfInteger@1.2.1"),
                Err(PackageError::UnsupportedType)
            ),
            "Type {} is not supported",
            "hackage"
        );
        match GenericPurl::<String>::from_str("pkg:hackage/AC-HalfInteger@1.2.1") {
            Ok(purl) => purl,
            Err(error) => {
                panic!(
                    "Failed to parse valid purl {:?}: {}",
                    "pkg:hackage/AC-HalfInteger@1.2.1", error
                )
            },
        }
    };
    assert_eq!("hackage", parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("AC-HalfInteger", parsed.name(), "Incorrect name");
    assert_eq!(Some("1.2.1"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:hackage/AC-HalfInteger@1.2.1", canonicalized,
        "Incorrect string representation"
    );
    let parsed_canonical = match GenericPurl::<String>::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse valid purl {:?}: {}", "pkg:hackage/AC-HalfInteger@1.2.1", error)
        },
    };
    assert_eq!(
        "hackage",
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.namespace(), "Incorrect namespace for canonicalized PURL");
    assert_eq!("AC-HalfInteger", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(
        Some("1.2.1"),
        parsed_canonical.version(),
        "Incorrect version for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// name and version are always required
fn name_and_version_are_always_required() {
    assert!(Purl::from_str("pkg:hackage").is_err(), "{}", "name and version are always required");
}
#[test]
/// minimal Hugging Face model
fn minimal_hugging_face_model() {
    let parsed = {
        assert!(
            matches!(
                Purl::from_str(
                    "pkg:huggingface/distilbert-base-uncased@\
                     043235d6088ecd3dd5fb5ca3592b6913fd516027"
                ),
                Err(PackageError::UnsupportedType)
            ),
            "Type {} is not supported",
            "huggingface"
        );
        match GenericPurl::<String>::from_str(
            "pkg:huggingface/distilbert-base-uncased@043235d6088ecd3dd5fb5ca3592b6913fd516027",
        ) {
            Ok(purl) => purl,
            Err(error) => {
                panic!(
                    "Failed to parse valid purl {:?}: {}",
                    "pkg:huggingface/distilbert-base-uncased@\
                     043235d6088ecd3dd5fb5ca3592b6913fd516027",
                    error
                )
            },
        }
    };
    assert_eq!("huggingface", parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("distilbert-base-uncased", parsed.name(), "Incorrect name");
    assert_eq!(
        Some("043235d6088ecd3dd5fb5ca3592b6913fd516027"),
        parsed.version(),
        "Incorrect version"
    );
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:huggingface/distilbert-base-uncased@043235d6088ecd3dd5fb5ca3592b6913fd516027",
        canonicalized,
        "Incorrect string representation"
    );
    let parsed_canonical = match GenericPurl::<String>::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:huggingface/distilbert-base-uncased@043235d6088ecd3dd5fb5ca3592b6913fd516027",
                error
            )
        },
    };
    assert_eq!(
        "huggingface",
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.namespace(), "Incorrect namespace for canonicalized PURL");
    assert_eq!(
        "distilbert-base-uncased",
        parsed_canonical.name(),
        "Incorrect name for canonicalized PURL"
    );
    assert_eq!(
        Some("043235d6088ecd3dd5fb5ca3592b6913fd516027"),
        parsed_canonical.version(),
        "Incorrect version for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// Hugging Face model with staging endpoint
fn hugging_face_model_with_staging_endpoint() {
    let parsed = {
        assert!(
            matches!(Purl::from_str("pkg:huggingface/microsoft/deberta-v3-base@559062ad13d311b87b2c455e67dcd5f1c8f65111?repository_url=https://hub-ci.huggingface.co"),
            Err(PackageError::UnsupportedType)), "Type {} is not supported",
            "huggingface"
        );
        match GenericPurl::<
            String,
        >::from_str(
            "pkg:huggingface/microsoft/deberta-v3-base@559062ad13d311b87b2c455e67dcd5f1c8f65111?repository_url=https://hub-ci.huggingface.co",
        ) {
            Ok(purl) => purl,
            Err(error) => {
                panic!(
                    "Failed to parse valid purl {:?}: {}",
                    "pkg:huggingface/microsoft/deberta-v3-base@559062ad13d311b87b2c455e67dcd5f1c8f65111?repository_url=https://hub-ci.huggingface.co",
                    error
                )
            }
        }
    };
    assert_eq!("huggingface", parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("microsoft"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("deberta-v3-base", parsed.name(), "Incorrect name");
    assert_eq!(
        Some("559062ad13d311b87b2c455e67dcd5f1c8f65111"),
        parsed.version(),
        "Incorrect version"
    );
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        [("repository_url", "https://hub-ci.huggingface.co")]
            .into_iter()
            .collect::<HashMap<&str, &str>>(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:huggingface/microsoft/deberta-v3-base@559062ad13d311b87b2c455e67dcd5f1c8f65111?repository_url=https://hub-ci.huggingface.co",
        canonicalized, "Incorrect string representation"
    );
    let parsed_canonical = match GenericPurl::<String>::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:huggingface/microsoft/deberta-v3-base@559062ad13d311b87b2c455e67dcd5f1c8f65111?repository_url=https://hub-ci.huggingface.co",
                error
            )
        },
    };
    assert_eq!(
        "huggingface",
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(
        Some("microsoft"),
        parsed_canonical.namespace(),
        "Incorrect namespace for canonicalized PURL"
    );
    assert_eq!("deberta-v3-base", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(
        Some("559062ad13d311b87b2c455e67dcd5f1c8f65111"),
        parsed_canonical.version(),
        "Incorrect version for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        [("repository_url", "https://hub-ci.huggingface.co")]
            .into_iter()
            .collect::<HashMap<&str, &str>>(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// MLflow model tracked in Azure ML (case sensitive)
fn m_lflow_model_tracked_in_azure_ml_case_sensitive_() {
    let parsed = {
        assert!(
            matches!(Purl::from_str("pkg:mlflow/CreditFraud@3?repository_url=https://westus2.api.azureml.ms/mlflow/v1.0/subscriptions/a50f2011-fab8-4164-af23-c62881ef8c95/resourceGroups/TestResourceGroup/providers/Microsoft.MachineLearningServices/workspaces/TestWorkspace"),
            Err(PackageError::UnsupportedType)), "Type {} is not supported", "mlflow"
        );
        match GenericPurl::<
            String,
        >::from_str(
            "pkg:mlflow/CreditFraud@3?repository_url=https://westus2.api.azureml.ms/mlflow/v1.0/subscriptions/a50f2011-fab8-4164-af23-c62881ef8c95/resourceGroups/TestResourceGroup/providers/Microsoft.MachineLearningServices/workspaces/TestWorkspace",
        ) {
            Ok(purl) => purl,
            Err(error) => {
                panic!(
                    "Failed to parse valid purl {:?}: {}",
                    "pkg:mlflow/CreditFraud@3?repository_url=https://westus2.api.azureml.ms/mlflow/v1.0/subscriptions/a50f2011-fab8-4164-af23-c62881ef8c95/resourceGroups/TestResourceGroup/providers/Microsoft.MachineLearningServices/workspaces/TestWorkspace",
                    error
                )
            }
        }
    };
    assert_eq!("mlflow", parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("CreditFraud", parsed.name(), "Incorrect name");
    assert_eq!(Some("3"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        [("repository_url",
        "https://westus2.api.azureml.ms/mlflow/v1.0/subscriptions/a50f2011-fab8-4164-af23-c62881ef8c95/resourceGroups/TestResourceGroup/providers/Microsoft.MachineLearningServices/workspaces/TestWorkspace")]
        .into_iter().collect:: < HashMap < & str, & str >> (), parsed.qualifiers().iter()
        .map(| (k, v) | (k.as_str(), v)).collect:: < HashMap < & str, & str >> (),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:mlflow/CreditFraud@3?repository_url=https://westus2.api.azureml.ms/mlflow/v1.0/subscriptions/a50f2011-fab8-4164-af23-c62881ef8c95/resourceGroups/TestResourceGroup/providers/Microsoft.MachineLearningServices/workspaces/TestWorkspace",
        canonicalized, "Incorrect string representation"
    );
    let parsed_canonical = match GenericPurl::<String>::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:mlflow/CreditFraud@3?repository_url=https://westus2.api.azureml.ms/mlflow/v1.0/subscriptions/a50f2011-fab8-4164-af23-c62881ef8c95/resourceGroups/TestResourceGroup/providers/Microsoft.MachineLearningServices/workspaces/TestWorkspace",
                error
            )
        },
    };
    assert_eq!(
        "mlflow",
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.namespace(), "Incorrect namespace for canonicalized PURL");
    assert_eq!("CreditFraud", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(Some("3"), parsed_canonical.version(), "Incorrect version for canonicalized PURL");
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        [("repository_url",
        "https://westus2.api.azureml.ms/mlflow/v1.0/subscriptions/a50f2011-fab8-4164-af23-c62881ef8c95/resourceGroups/TestResourceGroup/providers/Microsoft.MachineLearningServices/workspaces/TestWorkspace")]
        .into_iter().collect:: < HashMap < & str, & str >> (), parsed_canonical
        .qualifiers().iter().map(| (k, v) | (k.as_str(), v)).collect:: < HashMap < & str,
        & str >> (), "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// MLflow model with unique identifiers
fn m_lflow_model_with_unique_identifiers() {
    let parsed = {
        assert!(
            matches!(Purl::from_str("pkg:mlflow/trafficsigns@10?model_uuid=36233173b22f4c89b451f1228d700d49&run_id=410a3121-2709-4f88-98dd-dba0ef056b0a&repository_url=https://adb-5245952564735461.0.azuredatabricks.net/api/2.0/mlflow"),
            Err(PackageError::UnsupportedType)), "Type {} is not supported", "mlflow"
        );
        match GenericPurl::<
            String,
        >::from_str(
            "pkg:mlflow/trafficsigns@10?model_uuid=36233173b22f4c89b451f1228d700d49&run_id=410a3121-2709-4f88-98dd-dba0ef056b0a&repository_url=https://adb-5245952564735461.0.azuredatabricks.net/api/2.0/mlflow",
        ) {
            Ok(purl) => purl,
            Err(error) => {
                panic!(
                    "Failed to parse valid purl {:?}: {}",
                    "pkg:mlflow/trafficsigns@10?model_uuid=36233173b22f4c89b451f1228d700d49&run_id=410a3121-2709-4f88-98dd-dba0ef056b0a&repository_url=https://adb-5245952564735461.0.azuredatabricks.net/api/2.0/mlflow",
                    error
                )
            }
        }
    };
    assert_eq!("mlflow", parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("trafficsigns", parsed.name(), "Incorrect name");
    assert_eq!(Some("10"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        [
            ("model_uuid", "36233173b22f4c89b451f1228d700d49"),
            ("repository_url", "https://adb-5245952564735461.0.azuredatabricks.net/api/2.0/mlflow"),
            ("run_id", "410a3121-2709-4f88-98dd-dba0ef056b0a")
        ]
        .into_iter()
        .collect::<HashMap<&str, &str>>(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:mlflow/trafficsigns@10?model_uuid=36233173b22f4c89b451f1228d700d49&repository_url=https://adb-5245952564735461.0.azuredatabricks.net/api/2.0/mlflow&run_id=410a3121-2709-4f88-98dd-dba0ef056b0a",
        canonicalized, "Incorrect string representation"
    );
    let parsed_canonical = match GenericPurl::<String>::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:mlflow/trafficsigns@10?model_uuid=36233173b22f4c89b451f1228d700d49&run_id=410a3121-2709-4f88-98dd-dba0ef056b0a&repository_url=https://adb-5245952564735461.0.azuredatabricks.net/api/2.0/mlflow",
                error
            )
        },
    };
    assert_eq!(
        "mlflow",
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.namespace(), "Incorrect namespace for canonicalized PURL");
    assert_eq!("trafficsigns", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(Some("10"), parsed_canonical.version(), "Incorrect version for canonicalized PURL");
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        [
            ("model_uuid", "36233173b22f4c89b451f1228d700d49"),
            ("repository_url", "https://adb-5245952564735461.0.azuredatabricks.net/api/2.0/mlflow"),
            ("run_id", "410a3121-2709-4f88-98dd-dba0ef056b0a")
        ]
        .into_iter()
        .collect::<HashMap<&str, &str>>(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// valid go purl with uppercase in namespace
fn valid_go_purl_with_uppercase_in_namespace() {
    let parsed =
        match Purl::from_str("pkg:golang/github.com/GoogleCloudPlatform/cloud-sql-proxy/v2") {
            Ok(purl) => purl,
            Err(error) => {
                panic!(
                    "Failed to parse valid purl {:?}: {}",
                    "pkg:golang/github.com/GoogleCloudPlatform/cloud-sql-proxy/v2", error
                )
            },
        };
    assert_eq!(&PackageType::Golang, parsed.package_type(), "Incorrect package type");
    assert_eq!(
        Some("github.com/GoogleCloudPlatform/cloud-sql-proxy"),
        parsed.namespace(),
        "Incorrect namespace"
    );
    assert_eq!("v2", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:golang/github.com/GoogleCloudPlatform/cloud-sql-proxy/v2", canonicalized,
        "Incorrect string representation"
    );
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse canonical purl {:?}: {}",
                "pkg:golang/github.com/GoogleCloudPlatform/cloud-sql-proxy/v2", error
            )
        },
    };
    assert_eq!(
        &PackageType::Golang,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(
        Some("github.com/GoogleCloudPlatform/cloud-sql-proxy"),
        parsed_canonical.namespace(),
        "Incorrect namespace for canonicalized PURL"
    );
    assert_eq!("v2", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(None, parsed_canonical.version(), "Incorrect version for canonicalized PURL");
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// valid go purl with uppercase in name
fn valid_go_purl_with_uppercase_in_name() {
    let parsed = match Purl::from_str("pkg:golang/example.com/A") {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse valid purl {:?}: {}", "pkg:golang/example.com/A", error)
        },
    };
    assert_eq!(&PackageType::Golang, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("example.com"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("A", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!("pkg:golang/example.com/A", canonicalized, "Incorrect string representation");
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse canonical purl {:?}: {}", "pkg:golang/example.com/A", error)
        },
    };
    assert_eq!(
        &PackageType::Golang,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(
        Some("example.com"),
        parsed_canonical.namespace(),
        "Incorrect namespace for canonicalized PURL"
    );
    assert_eq!("A", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(None, parsed_canonical.version(), "Incorrect version for canonicalized PURL");
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// valid go purl without namespace
fn valid_go_purl_without_namespace() {
    let parsed = match Purl::from_str("pkg:golang/v.io") {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse valid purl {:?}: {}", "pkg:golang/v.io", error)
        },
    };
    assert_eq!(&PackageType::Golang, parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("v.io", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!("pkg:golang/v.io", canonicalized, "Incorrect string representation");
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse canonical purl {:?}: {}", "pkg:golang/v.io", error)
        },
    };
    assert_eq!(
        &PackageType::Golang,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.namespace(), "Incorrect namespace for canonicalized PURL");
    assert_eq!("v.io", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(None, parsed_canonical.version(), "Incorrect version for canonicalized PURL");
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// valid npm purl with uppercase in name
fn valid_npm_purl_with_uppercase_in_name() {
    let parsed = match Purl::from_str("pkg:npm/parseUri") {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse valid purl {:?}: {}", "pkg:npm/parseUri", error)
        },
    };
    assert_eq!(&PackageType::Npm, parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("parseUri", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!("pkg:npm/parseUri", canonicalized, "Incorrect string representation");
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse canonical purl {:?}: {}", "pkg:npm/parseUri", error)
        },
    };
    assert_eq!(
        &PackageType::Npm,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.namespace(), "Incorrect namespace for canonicalized PURL");
    assert_eq!("parseUri", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(None, parsed_canonical.version(), "Incorrect version for canonicalized PURL");
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// valid cargo purl with uppercase in name
fn valid_cargo_purl_with_uppercase_in_name() {
    let parsed = match Purl::from_str("pkg:cargo/Inflector") {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse valid purl {:?}: {}", "pkg:cargo/Inflector", error)
        },
    };
    assert_eq!(&PackageType::Cargo, parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("Inflector", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!("pkg:cargo/Inflector", canonicalized, "Incorrect string representation");
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse canonical purl {:?}: {}", "pkg:cargo/Inflector", error)
        },
    };
    assert_eq!(
        &PackageType::Cargo,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.namespace(), "Incorrect namespace for canonicalized PURL");
    assert_eq!("Inflector", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(None, parsed_canonical.version(), "Incorrect version for canonicalized PURL");
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// non-canonical nuget purl with uppercase in name
fn non_canonical_nuget_purl_with_uppercase_in_name() {
    let parsed = match Purl::from_str("pkg:nuget/Newtonsoft.Json") {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse valid purl {:?}: {}", "pkg:nuget/Newtonsoft.Json", error)
        },
    };
    assert_eq!(&PackageType::NuGet, parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("newtonsoft.json", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!("pkg:nuget/newtonsoft.json", canonicalized, "Incorrect string representation");
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse canonical purl {:?}: {}", "pkg:nuget/Newtonsoft.Json", error)
        },
    };
    assert_eq!(
        &PackageType::NuGet,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.namespace(), "Incorrect namespace for canonicalized PURL");
    assert_eq!("newtonsoft.json", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(None, parsed_canonical.version(), "Incorrect version for canonicalized PURL");
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// non-canonical pypi purl with uppercase in name
fn non_canonical_pypi_purl_with_uppercase_in_name() {
    let parsed = match Purl::from_str("pkg:pypi/PyTest") {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse valid purl {:?}: {}", "pkg:pypi/PyTest", error)
        },
    };
    assert_eq!(&PackageType::PyPI, parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("pytest", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!("pkg:pypi/pytest", canonicalized, "Incorrect string representation");
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse canonical purl {:?}: {}", "pkg:pypi/PyTest", error)
        },
    };
    assert_eq!(
        &PackageType::PyPI,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.namespace(), "Incorrect namespace for canonicalized PURL");
    assert_eq!("pytest", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(None, parsed_canonical.version(), "Incorrect version for canonicalized PURL");
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// non-canonical pypi purl with specials in name
fn non_canonical_pypi_purl_with_specials_in_name() {
    let parsed = match Purl::from_str("pkg:pypi/_-.-_special_-.-_name_-.-_") {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:pypi/_-.-_special_-.-_name_-.-_", error
            )
        },
    };
    assert_eq!(&PackageType::PyPI, parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("-special-name-", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!("pkg:pypi/-special-name-", canonicalized, "Incorrect string representation");
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse canonical purl {:?}: {}",
                "pkg:pypi/_-.-_special_-.-_name_-.-_", error
            )
        },
    };
    assert_eq!(
        &PackageType::PyPI,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.namespace(), "Incorrect namespace for canonicalized PURL");
    assert_eq!("-special-name-", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(None, parsed_canonical.version(), "Incorrect version for canonicalized PURL");
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// invalid maven purl without namespace
fn invalid_maven_purl_without_namespace() {
    assert!(
        Purl::from_str("pkg:maven/invalid").is_err(),
        "{}",
        "invalid maven purl without namespace"
    );
}
#[test]
/// plus signs and spaces
fn plus_signs_and_spaces() {
    let parsed =
        match Purl::from_str("pkg:cargo/example?repository_url=https://example.com/a%20b+c/") {
            Ok(purl) => purl,
            Err(error) => {
                panic!(
                    "Failed to parse valid purl {:?}: {}",
                    "pkg:cargo/example?repository_url=https://example.com/a%20b+c/", error
                )
            },
        };
    assert_eq!(&PackageType::Cargo, parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("example", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        [("repository_url", "https://example.com/a b+c/")]
            .into_iter()
            .collect::<HashMap<&str, &str>>(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:cargo/example?repository_url=https://example.com/a%20b%2Bc/", canonicalized,
        "Incorrect string representation"
    );
    let parsed_canonical = match Purl::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse canonical purl {:?}: {}",
                "pkg:cargo/example?repository_url=https://example.com/a%20b+c/", error
            )
        },
    };
    assert_eq!(
        &PackageType::Cargo,
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.namespace(), "Incorrect namespace for canonicalized PURL");
    assert_eq!("example", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(None, parsed_canonical.version(), "Incorrect version for canonicalized PURL");
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        [("repository_url", "https://example.com/a b+c/")]
            .into_iter()
            .collect::<HashMap<&str, &str>>(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// percent signs are properly encoded and decoded
fn percent_signs_are_properly_encoded_and_decoded() {
    let parsed = {
        assert!(
            matches!(Purl::from_str("pkg:generic/100%25/100%25@100%25?repository_url=https://example.com/100%2525/#100%25"),
            Err(PackageError::UnsupportedType)), "Type {} is not supported", "generic"
        );
        match GenericPurl::<String>::from_str(
            "pkg:generic/100%25/100%25@100%25?repository_url=https://example.com/100%2525/#100%25",
        ) {
            Ok(purl) => purl,
            Err(error) => {
                panic!(
                    "Failed to parse valid purl {:?}: {}",
                    "pkg:generic/100%25/100%25@100%25?repository_url=https://example.com/100%2525/#100%25",
                    error
                )
            },
        }
    };
    assert_eq!("generic", parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("100%"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("100%", parsed.name(), "Incorrect name");
    assert_eq!(Some("100%"), parsed.version(), "Incorrect version");
    assert_eq!(Some("100%"), parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        [("repository_url", "https://example.com/100%25/")]
            .into_iter()
            .collect::<HashMap<&str, &str>>(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!(
        "pkg:generic/100%25/100%25@100%25?repository_url=https://example.com/100%2525/#100%25",
        canonicalized,
        "Incorrect string representation"
    );
    let parsed_canonical = match GenericPurl::<String>::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:generic/100%25/100%25@100%25?repository_url=https://example.com/100%2525/#100%25",
                error
            )
        },
    };
    assert_eq!(
        "generic",
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(
        Some("100%"),
        parsed_canonical.namespace(),
        "Incorrect namespace for canonicalized PURL"
    );
    assert_eq!("100%", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(
        Some("100%"),
        parsed_canonical.version(),
        "Incorrect version for canonicalized PURL"
    );
    assert_eq!(
        Some("100%"),
        parsed_canonical.subpath(),
        "Incorrect subpath for canonicalized PURL"
    );
    assert_eq!(
        [("repository_url", "https://example.com/100%25/")]
            .into_iter()
            .collect::<HashMap<&str, &str>>(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
#[test]
/// version encoding
fn version_encoding() {
    let parsed = {
        assert!(
            matches!(
                Purl::from_str("pkg:generic/name@a%23%2Fb%3F%2Fc%40"),
                Err(PackageError::UnsupportedType)
            ),
            "Type {} is not supported",
            "generic"
        );
        match GenericPurl::<String>::from_str("pkg:generic/name@a%23%2Fb%3F%2Fc%40") {
            Ok(purl) => purl,
            Err(error) => {
                panic!(
                    "Failed to parse valid purl {:?}: {}",
                    "pkg:generic/name@a%23%2Fb%3F%2Fc%40", error
                )
            },
        }
    };
    assert_eq!("generic", parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("name", parsed.name(), "Incorrect name");
    assert_eq!(Some("a#/b?/c@"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers"
    );
    let canonicalized = parsed.to_string();
    assert_eq!("pkg:generic/name@a%23/b%3F/c%40", canonicalized, "Incorrect string representation");
    let parsed_canonical = match GenericPurl::<String>::from_str(&canonicalized) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:generic/name@a%23%2Fb%3F%2Fc%40", error
            )
        },
    };
    assert_eq!(
        "generic",
        parsed_canonical.package_type(),
        "Incorrect package type for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.namespace(), "Incorrect namespace for canonicalized PURL");
    assert_eq!("name", parsed_canonical.name(), "Incorrect name for canonicalized PURL");
    assert_eq!(
        Some("a#/b?/c@"),
        parsed_canonical.version(),
        "Incorrect version for canonicalized PURL"
    );
    assert_eq!(None, parsed_canonical.subpath(), "Incorrect subpath for canonicalized PURL");
    assert_eq!(
        HashMap::<&str, &str>::new(),
        parsed_canonical
            .qualifiers()
            .iter()
            .map(|(k, v)| (k.as_str(), v))
            .collect::<HashMap<&str, &str>>(),
        "Incorrect qualifiers for canonicalized PURL"
    );
}
