// This file is autogenerated by generate_tests.rs.
// Use `cargo xtask codegen` to regenerate it.
#![cfg(test)]

use std::collections::HashMap;
use std::str::FromStr;

use purl::{GenericPurl, PackageError, PackageType, Purl};
#[test]
/// valid maven purl
fn valid_maven_purl() {
    let parsed = match Purl::from_str("pkg:maven/org.apache.commons/io@1.3.4") {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:maven/org.apache.commons/io@1.3.4", error
            )
        },
    };
    assert_eq!(&PackageType::Maven, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("org.apache.commons"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("io", parsed.name(), "Incorrect name");
    assert_eq!(Some("1.3.4"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:maven/org.apache.commons/io@1.3.4",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// basic valid maven purl without version
fn basic_valid_maven_purl_without_version() {
    let parsed = match Purl::from_str("pkg:maven/org.apache.commons/io") {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse valid purl {:?}: {}", "pkg:maven/org.apache.commons/io", error)
        },
    };
    assert_eq!(&PackageType::Maven, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("org.apache.commons"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("io", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:maven/org.apache.commons/io",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// valid go purl without version and with subpath
fn valid_go_purl_without_version_and_with_subpath() {
    let parsed = match Purl::from_str(
        "pkg:GOLANG/google.golang.org/genproto#/googleapis/api/annotations/",
    ) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:GOLANG/google.golang.org/genproto#/googleapis/api/annotations/", error
            )
        },
    };
    assert_eq!(&PackageType::Golang, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("google.golang.org"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("genproto", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(Some("googleapis/api/annotations"), parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:golang/google.golang.org/genproto#googleapis/api/annotations",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// valid go purl with version and subpath
fn valid_go_purl_with_version_and_subpath() {
    let parsed = match Purl::from_str(
        "pkg:GOLANG/google.golang.org/genproto@abcdedf#/googleapis/api/annotations/",
    ) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:GOLANG/google.golang.org/genproto@abcdedf#/googleapis/api/annotations/", error
            )
        },
    };
    assert_eq!(&PackageType::Golang, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("google.golang.org"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("genproto", parsed.name(), "Incorrect name");
    assert_eq!(Some("abcdedf"), parsed.version(), "Incorrect version");
    assert_eq!(Some("googleapis/api/annotations"), parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:golang/google.golang.org/genproto@abcdedf#googleapis/api/annotations",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// unsupported: debian can use qualifiers
fn unsupported_debian_can_use_qualifiers() {
    assert!(
        matches!(
            Purl::from_str("pkg:deb/debian/curl@7.50.3-1?arch=i386&distro=jessie"),
            Err(PackageError::UnsupportedType)
        ),
        "Type {} is not supported",
        "deb"
    );
    let parsed = match GenericPurl::<String>::from_str(
        "pkg:deb/debian/curl@7.50.3-1?arch=i386&distro=jessie",
    ) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:deb/debian/curl@7.50.3-1?arch=i386&distro=jessie", error
            )
        },
    };
    assert_eq!("deb", parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("debian"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("curl", parsed.name(), "Incorrect name");
    assert_eq!(Some("7.50.3-1"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> =
        [("arch", "i386"), ("distro", "jessie")].into_iter().collect();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:deb/debian/curl@7.50.3-1?arch=i386&distro=jessie",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// unsupported: docker uses qualifiers and hash image id as versions
fn unsupported_docker_uses_qualifiers_and_hash_image_id_as_versions() {
    assert!(
        matches!(
            Purl::from_str(
                "pkg:docker/customer/dockerimage@sha256:244fd47e07d1004f0aed9c?repository_url=gcr.\
                 io"
            ),
            Err(PackageError::UnsupportedType)
        ),
        "Type {} is not supported",
        "docker"
    );
    let parsed = match GenericPurl::<String>::from_str(
        "pkg:docker/customer/dockerimage@sha256:244fd47e07d1004f0aed9c?repository_url=gcr.io",
    ) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:docker/customer/dockerimage@sha256:244fd47e07d1004f0aed9c?repository_url=gcr.\
                 io",
                error
            )
        },
    };
    assert_eq!("docker", parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("customer"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("dockerimage", parsed.name(), "Incorrect name");
    assert_eq!(Some("sha256:244fd47e07d1004f0aed9c"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> =
        [("repository_url", "gcr.io")].into_iter().collect();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:docker/customer/dockerimage@sha256:244fd47e07d1004f0aed9c?repository_url=gcr.io",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// Java gem can use a qualifier
fn java_gem_can_use_a_qualifier() {
    let parsed = match Purl::from_str("pkg:gem/jruby-launcher@1.1.2?Platform=java") {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:gem/jruby-launcher@1.1.2?Platform=java", error
            )
        },
    };
    assert_eq!(&PackageType::Gem, parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("jruby-launcher", parsed.name(), "Incorrect name");
    assert_eq!(Some("1.1.2"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = [("platform", "java")].into_iter().collect();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:gem/jruby-launcher@1.1.2?platform=java",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// maven often uses qualifiers
fn maven_often_uses_qualifiers() {
    let parsed = match Purl::from_str(
        "pkg:Maven/org.apache.xmlgraphics/batik-anim@1.9.1?classifier=sources&repositorY_url=repo.\
         spring.io/release",
    ) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:Maven/org.apache.xmlgraphics/batik-anim@1.9.1?classifier=sources&\
                 repositorY_url=repo.spring.io/release",
                error
            )
        },
    };
    assert_eq!(&PackageType::Maven, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("org.apache.xmlgraphics"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("batik-anim", parsed.name(), "Incorrect name");
    assert_eq!(Some("1.9.1"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> =
        [("classifier", "sources"), ("repository_url", "repo.spring.io/release")]
            .into_iter()
            .collect();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:maven/org.apache.xmlgraphics/batik-anim@1.9.1?classifier=sources&repository_url=repo.\
         spring.io/release",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// maven pom reference
fn maven_pom_reference() {
    let parsed = match Purl::from_str(
        "pkg:Maven/org.apache.xmlgraphics/batik-anim@1.9.1?extension=pom&repositorY_url=repo.\
         spring.io/release",
    ) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:Maven/org.apache.xmlgraphics/batik-anim@1.9.1?extension=pom&\
                 repositorY_url=repo.spring.io/release",
                error
            )
        },
    };
    assert_eq!(&PackageType::Maven, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("org.apache.xmlgraphics"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("batik-anim", parsed.name(), "Incorrect name");
    assert_eq!(Some("1.9.1"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> =
        [("extension", "pom"), ("repository_url", "repo.spring.io/release")].into_iter().collect();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:maven/org.apache.xmlgraphics/batik-anim@1.9.1?extension=pom&repository_url=repo.\
         spring.io/release",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// maven can come with a type qualifier
fn maven_can_come_with_a_type_qualifier() {
    let parsed =
        match Purl::from_str("pkg:Maven/net.sf.jacob-project/jacob@1.14.3?classifier=x86&type=dll")
        {
            Ok(purl) => purl,
            Err(error) => {
                panic!(
                    "Failed to parse valid purl {:?}: {}",
                    "pkg:Maven/net.sf.jacob-project/jacob@1.14.3?classifier=x86&type=dll", error
                )
            },
        };
    assert_eq!(&PackageType::Maven, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("net.sf.jacob-project"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("jacob", parsed.name(), "Incorrect name");
    assert_eq!(Some("1.14.3"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> =
        [("classifier", "x86"), ("type", "dll")].into_iter().collect();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:maven/net.sf.jacob-project/jacob@1.14.3?classifier=x86&type=dll",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// npm can be scoped
fn npm_can_be_scoped() {
    let parsed = match Purl::from_str("pkg:npm/%40angular/animation@12.3.1") {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:npm/%40angular/animation@12.3.1", error
            )
        },
    };
    assert_eq!(&PackageType::Npm, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("@angular"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("animation", parsed.name(), "Incorrect name");
    assert_eq!(Some("12.3.1"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:npm/%40angular/animation@12.3.1",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// pypi names have special rules and not case sensitive
fn pypi_names_have_special_rules_and_not_case_sensitive() {
    let parsed = match Purl::from_str("pkg:PYPI/Django_package@1.11.1.dev1") {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:PYPI/Django_package@1.11.1.dev1", error
            )
        },
    };
    assert_eq!(&PackageType::PyPI, parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("django-package", parsed.name(), "Incorrect name");
    assert_eq!(Some("1.11.1.dev1"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:pypi/django-package@1.11.1.dev1",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// unsupported: rpm often use qualifiers
fn unsupported_rpm_often_use_qualifiers() {
    assert!(
        matches!(
            Purl::from_str("pkg:Rpm/fedora/curl@7.50.3-1.fc25?Arch=i386&Distro=fedora-25"),
            Err(PackageError::UnsupportedType)
        ),
        "Type {} is not supported",
        "rpm"
    );
    let parsed = match GenericPurl::<String>::from_str(
        "pkg:Rpm/fedora/curl@7.50.3-1.fc25?Arch=i386&Distro=fedora-25",
    ) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:Rpm/fedora/curl@7.50.3-1.fc25?Arch=i386&Distro=fedora-25", error
            )
        },
    };
    assert_eq!("rpm", parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("fedora"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("curl", parsed.name(), "Incorrect name");
    assert_eq!(Some("7.50.3-1.fc25"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> =
        [("arch", "i386"), ("distro", "fedora-25")].into_iter().collect();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:rpm/fedora/curl@7.50.3-1.fc25?arch=i386&distro=fedora-25",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// a scheme is always required
fn a_scheme_is_always_required() {
    assert!(
        Purl::from_str("EnterpriseLibrary.Common@6.0.1304").is_err(),
        "{}",
        "a scheme is always required"
    );
}
#[test]
/// a type is always required
fn a_type_is_always_required() {
    assert!(
        Purl::from_str("pkg:EnterpriseLibrary.Common@6.0.1304").is_err(),
        "{}",
        "a type is always required"
    );
}
#[test]
/// a name is required
fn a_name_is_required() {
    assert!(Purl::from_str("pkg:maven/@1.3.4").is_err(), "{}", "a name is required");
}
#[test]
/// slash / after scheme is not significant
fn slash_after_scheme_is_not_significant() {
    let parsed = match Purl::from_str("pkg:/maven/org.apache.commons/io") {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse valid purl {:?}: {}", "pkg:/maven/org.apache.commons/io", error)
        },
    };
    assert_eq!(&PackageType::Maven, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("org.apache.commons"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("io", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:maven/org.apache.commons/io",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// double slash // after scheme is not significant
fn double_slash_after_scheme_is_not_significant() {
    let parsed = match Purl::from_str("pkg://maven/org.apache.commons/io") {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg://maven/org.apache.commons/io", error
            )
        },
    };
    assert_eq!(&PackageType::Maven, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("org.apache.commons"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("io", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:maven/org.apache.commons/io",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// slash /// after type  is not significant
fn slash_after_type_is_not_significant() {
    let parsed = match Purl::from_str("pkg:///maven/org.apache.commons/io") {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:///maven/org.apache.commons/io", error
            )
        },
    };
    assert_eq!(&PackageType::Maven, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("org.apache.commons"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("io", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:maven/org.apache.commons/io",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// valid maven purl with case sensitive namespace and name
fn valid_maven_purl_with_case_sensitive_namespace_and_name() {
    let parsed = match Purl::from_str("pkg:maven/HTTPClient/HTTPClient@0.3-3") {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:maven/HTTPClient/HTTPClient@0.3-3", error
            )
        },
    };
    assert_eq!(&PackageType::Maven, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("HTTPClient"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("HTTPClient", parsed.name(), "Incorrect name");
    assert_eq!(Some("0.3-3"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:maven/HTTPClient/HTTPClient@0.3-3",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// valid maven purl containing a space in the version and qualifier
fn valid_maven_purl_containing_a_space_in_the_version_and_qualifier() {
    let parsed = match Purl::from_str("pkg:maven/mygroup/myartifact@1.0.0%20Final?mykey=my%20value")
    {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:maven/mygroup/myartifact@1.0.0%20Final?mykey=my%20value", error
            )
        },
    };
    assert_eq!(&PackageType::Maven, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("mygroup"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("myartifact", parsed.name(), "Incorrect name");
    assert_eq!(Some("1.0.0 Final"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = [("mykey", "my value")].into_iter().collect();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:maven/mygroup/myartifact@1.0.0%20Final?mykey=my%20value",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// checks for invalid qualifier keys
fn checks_for_invalid_qualifier_keys() {
    assert!(
        Purl::from_str("pkg:npm/myartifact@1.0.0?in%20production=true").is_err(),
        "{}",
        "checks for invalid qualifier keys"
    );
}
#[test]
/// unsupported: valid conan purl
fn unsupported_valid_conan_purl() {
    assert!(
        matches!(Purl::from_str("pkg:conan/cctz@2.3"), Err(PackageError::UnsupportedType)),
        "Type {} is not supported",
        "conan"
    );
    let parsed = match GenericPurl::<String>::from_str("pkg:conan/cctz@2.3") {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse valid purl {:?}: {}", "pkg:conan/cctz@2.3", error)
        },
    };
    assert_eq!("conan", parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("cctz", parsed.name(), "Incorrect name");
    assert_eq!(Some("2.3"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!("pkg:conan/cctz@2.3", &parsed.to_string(), "Incorrect string representation");
}
#[test]
/// unsupported: valid conan purl with namespace and qualifier channel
fn unsupported_valid_conan_purl_with_namespace_and_qualifier_channel() {
    assert!(
        matches!(
            Purl::from_str("pkg:conan/bincrafters/cctz@2.3?channel=stable"),
            Err(PackageError::UnsupportedType)
        ),
        "Type {} is not supported",
        "conan"
    );
    let parsed =
        match GenericPurl::<String>::from_str("pkg:conan/bincrafters/cctz@2.3?channel=stable") {
            Ok(purl) => purl,
            Err(error) => {
                panic!(
                    "Failed to parse valid purl {:?}: {}",
                    "pkg:conan/bincrafters/cctz@2.3?channel=stable", error
                )
            },
        };
    assert_eq!("conan", parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("bincrafters"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("cctz", parsed.name(), "Incorrect name");
    assert_eq!(Some("2.3"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = [("channel", "stable")].into_iter().collect();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:conan/bincrafters/cctz@2.3?channel=stable",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// invalid conan purl only namespace
fn invalid_conan_purl_only_namespace() {
    assert!(
        Purl::from_str("pkg:conan/bincrafters/cctz@2.3").is_err(),
        "{}",
        "invalid conan purl only namespace"
    );
}
#[test]
/// invalid conan purl only channel qualifier
fn invalid_conan_purl_only_channel_qualifier() {
    assert!(
        Purl::from_str("pkg:conan/cctz@2.3?channel=stable").is_err(),
        "{}",
        "invalid conan purl only channel qualifier"
    );
}
#[test]
/// unsupported: valid conda purl with qualifiers
fn unsupported_valid_conda_purl_with_qualifiers() {
    assert!(
        matches!(
            Purl::from_str(
                "pkg:conda/absl-py@0.4.1?build=py36h06a4308_0&channel=main&subdir=linux-64&\
                 type=tar.bz2"
            ),
            Err(PackageError::UnsupportedType)
        ),
        "Type {} is not supported",
        "conda"
    );
    let parsed = match GenericPurl::<String>::from_str(
        "pkg:conda/absl-py@0.4.1?build=py36h06a4308_0&channel=main&subdir=linux-64&type=tar.bz2",
    ) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:conda/absl-py@0.4.1?build=py36h06a4308_0&channel=main&subdir=linux-64&\
                 type=tar.bz2",
                error
            )
        },
    };
    assert_eq!("conda", parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("absl-py", parsed.name(), "Incorrect name");
    assert_eq!(Some("0.4.1"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = [
        ("build", "py36h06a4308_0"),
        ("channel", "main"),
        ("subdir", "linux-64"),
        ("type", "tar.bz2"),
    ]
    .into_iter()
    .collect();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:conda/absl-py@0.4.1?build=py36h06a4308_0&channel=main&subdir=linux-64&type=tar.bz2",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// unsupported: valid cran purl
fn unsupported_valid_cran_purl() {
    assert!(
        matches!(Purl::from_str("pkg:cran/A3@0.9.1"), Err(PackageError::UnsupportedType)),
        "Type {} is not supported",
        "cran"
    );
    let parsed = match GenericPurl::<String>::from_str("pkg:cran/A3@0.9.1") {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse valid purl {:?}: {}", "pkg:cran/A3@0.9.1", error)
        },
    };
    assert_eq!("cran", parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("A3", parsed.name(), "Incorrect name");
    assert_eq!(Some("0.9.1"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!("pkg:cran/A3@0.9.1", &parsed.to_string(), "Incorrect string representation");
}
#[test]
/// invalid cran purl without name
fn invalid_cran_purl_without_name() {
    assert!(Purl::from_str("pkg:cran/@0.9.1").is_err(), "{}", "invalid cran purl without name");
}
#[test]
/// invalid cran purl without version
fn invalid_cran_purl_without_version() {
    assert!(Purl::from_str("pkg:cran/A3").is_err(), "{}", "invalid cran purl without version");
}
#[test]
/// unsupported: valid swift purl
fn unsupported_valid_swift_purl() {
    assert!(
        matches!(
            Purl::from_str("pkg:swift/github.com/Alamofire/Alamofire@5.4.3"),
            Err(PackageError::UnsupportedType)
        ),
        "Type {} is not supported",
        "swift"
    );
    let parsed =
        match GenericPurl::<String>::from_str("pkg:swift/github.com/Alamofire/Alamofire@5.4.3") {
            Ok(purl) => purl,
            Err(error) => {
                panic!(
                    "Failed to parse valid purl {:?}: {}",
                    "pkg:swift/github.com/Alamofire/Alamofire@5.4.3", error
                )
            },
        };
    assert_eq!("swift", parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("github.com/Alamofire"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("Alamofire", parsed.name(), "Incorrect name");
    assert_eq!(Some("5.4.3"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:swift/github.com/Alamofire/Alamofire@5.4.3",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// invalid swift purl without namespace
fn invalid_swift_purl_without_namespace() {
    assert!(
        Purl::from_str("pkg:swift/Alamofire@5.4.3").is_err(),
        "{}",
        "invalid swift purl without namespace"
    );
}
#[test]
/// invalid swift purl without name
fn invalid_swift_purl_without_name() {
    assert!(
        Purl::from_str("pkg:swift/github.com/Alamofire/@5.4.3").is_err(),
        "{}",
        "invalid swift purl without name"
    );
}
#[test]
/// invalid swift purl without version
fn invalid_swift_purl_without_version() {
    assert!(
        Purl::from_str("pkg:swift/github.com/Alamofire/Alamofire").is_err(),
        "{}",
        "invalid swift purl without version"
    );
}
#[test]
/// unsupported: valid hackage purl
fn unsupported_valid_hackage_purl() {
    assert!(
        matches!(
            Purl::from_str("pkg:hackage/AC-HalfInteger@1.2.1"),
            Err(PackageError::UnsupportedType)
        ),
        "Type {} is not supported",
        "hackage"
    );
    let parsed = match GenericPurl::<String>::from_str("pkg:hackage/AC-HalfInteger@1.2.1") {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse valid purl {:?}: {}", "pkg:hackage/AC-HalfInteger@1.2.1", error)
        },
    };
    assert_eq!("hackage", parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("AC-HalfInteger", parsed.name(), "Incorrect name");
    assert_eq!(Some("1.2.1"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:hackage/AC-HalfInteger@1.2.1",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// name and version are always required
fn name_and_version_are_always_required() {
    assert!(Purl::from_str("pkg:hackage").is_err(), "{}", "name and version are always required");
}
#[test]
/// unsupported: minimal Hugging Face model
fn unsupported_minimal_hugging_face_model() {
    assert!(
        matches!(
            Purl::from_str(
                "pkg:huggingface/distilbert-base-uncased@043235d6088ecd3dd5fb5ca3592b6913fd516027"
            ),
            Err(PackageError::UnsupportedType)
        ),
        "Type {} is not supported",
        "huggingface"
    );
    let parsed = match GenericPurl::<String>::from_str(
        "pkg:huggingface/distilbert-base-uncased@043235d6088ecd3dd5fb5ca3592b6913fd516027",
    ) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:huggingface/distilbert-base-uncased@043235d6088ecd3dd5fb5ca3592b6913fd516027",
                error
            )
        },
    };
    assert_eq!("huggingface", parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("distilbert-base-uncased", parsed.name(), "Incorrect name");
    assert_eq!(
        Some("043235d6088ecd3dd5fb5ca3592b6913fd516027"),
        parsed.version(),
        "Incorrect version"
    );
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:huggingface/distilbert-base-uncased@043235d6088ecd3dd5fb5ca3592b6913fd516027",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// unsupported: Hugging Face model with staging endpoint
fn unsupported_hugging_face_model_with_staging_endpoint() {
    assert!(
        matches!(Purl::from_str("pkg:huggingface/microsoft/deberta-v3-base@559062ad13d311b87b2c455e67dcd5f1c8f65111?repository_url=https://hub-ci.huggingface.co"),
        Err(PackageError::UnsupportedType)), "Type {} is not supported", "huggingface"
    );
    let parsed = match GenericPurl::<
        String,
    >::from_str(
        "pkg:huggingface/microsoft/deberta-v3-base@559062ad13d311b87b2c455e67dcd5f1c8f65111?repository_url=https://hub-ci.huggingface.co",
    ) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:huggingface/microsoft/deberta-v3-base@559062ad13d311b87b2c455e67dcd5f1c8f65111?repository_url=https://hub-ci.huggingface.co",
                error
            )
        }
    };
    assert_eq!("huggingface", parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("microsoft"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("deberta-v3-base", parsed.name(), "Incorrect name");
    assert_eq!(
        Some("559062ad13d311b87b2c455e67dcd5f1c8f65111"),
        parsed.version(),
        "Incorrect version"
    );
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> =
        [("repository_url", "https://hub-ci.huggingface.co")].into_iter().collect();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:huggingface/microsoft/deberta-v3-base@559062ad13d311b87b2c455e67dcd5f1c8f65111?repository_url=https://hub-ci.huggingface.co",
        & parsed.to_string(), "Incorrect string representation"
    );
}
#[test]
/// unsupported: MLflow model tracked in Azure ML (case sensitive)
fn unsupported_m_lflow_model_tracked_in_azure_ml_case_sensitive_() {
    assert!(
        matches!(Purl::from_str("pkg:mlflow/CreditFraud@3?repository_url=https://westus2.api.azureml.ms/mlflow/v1.0/subscriptions/a50f2011-fab8-4164-af23-c62881ef8c95/resourceGroups/TestResourceGroup/providers/Microsoft.MachineLearningServices/workspaces/TestWorkspace"),
        Err(PackageError::UnsupportedType)), "Type {} is not supported", "mlflow"
    );
    let parsed = match GenericPurl::<
        String,
    >::from_str(
        "pkg:mlflow/CreditFraud@3?repository_url=https://westus2.api.azureml.ms/mlflow/v1.0/subscriptions/a50f2011-fab8-4164-af23-c62881ef8c95/resourceGroups/TestResourceGroup/providers/Microsoft.MachineLearningServices/workspaces/TestWorkspace",
    ) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:mlflow/CreditFraud@3?repository_url=https://westus2.api.azureml.ms/mlflow/v1.0/subscriptions/a50f2011-fab8-4164-af23-c62881ef8c95/resourceGroups/TestResourceGroup/providers/Microsoft.MachineLearningServices/workspaces/TestWorkspace",
                error
            )
        }
    };
    assert_eq!("mlflow", parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("CreditFraud", parsed.name(), "Incorrect name");
    assert_eq!(Some("3"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = [
        (
            "repository_url",
            "https://westus2.api.azureml.ms/mlflow/v1.0/subscriptions/a50f2011-fab8-4164-af23-c62881ef8c95/resourceGroups/TestResourceGroup/providers/Microsoft.MachineLearningServices/workspaces/TestWorkspace",
        ),
    ]
        .into_iter()
        .collect();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:mlflow/CreditFraud@3?repository_url=https://westus2.api.azureml.ms/mlflow/v1.0/subscriptions/a50f2011-fab8-4164-af23-c62881ef8c95/resourceGroups/TestResourceGroup/providers/Microsoft.MachineLearningServices/workspaces/TestWorkspace",
        & parsed.to_string(), "Incorrect string representation"
    );
}
#[test]
/// unsupported: MLflow model with unique identifiers
fn unsupported_m_lflow_model_with_unique_identifiers() {
    assert!(
        matches!(Purl::from_str("pkg:mlflow/trafficsigns@10?model_uuid=36233173b22f4c89b451f1228d700d49&run_id=410a3121-2709-4f88-98dd-dba0ef056b0a&repository_url=https://adb-5245952564735461.0.azuredatabricks.net/api/2.0/mlflow"),
        Err(PackageError::UnsupportedType)), "Type {} is not supported", "mlflow"
    );
    let parsed = match GenericPurl::<
        String,
    >::from_str(
        "pkg:mlflow/trafficsigns@10?model_uuid=36233173b22f4c89b451f1228d700d49&run_id=410a3121-2709-4f88-98dd-dba0ef056b0a&repository_url=https://adb-5245952564735461.0.azuredatabricks.net/api/2.0/mlflow",
    ) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:mlflow/trafficsigns@10?model_uuid=36233173b22f4c89b451f1228d700d49&run_id=410a3121-2709-4f88-98dd-dba0ef056b0a&repository_url=https://adb-5245952564735461.0.azuredatabricks.net/api/2.0/mlflow",
                error
            )
        }
    };
    assert_eq!("mlflow", parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("trafficsigns", parsed.name(), "Incorrect name");
    assert_eq!(Some("10"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = [
        ("model_uuid", "36233173b22f4c89b451f1228d700d49"),
        ("repository_url", "https://adb-5245952564735461.0.azuredatabricks.net/api/2.0/mlflow"),
        ("run_id", "410a3121-2709-4f88-98dd-dba0ef056b0a"),
    ]
    .into_iter()
    .collect();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:mlflow/trafficsigns@10?model_uuid=36233173b22f4c89b451f1228d700d49&repository_url=https://adb-5245952564735461.0.azuredatabricks.net/api/2.0/mlflow&run_id=410a3121-2709-4f88-98dd-dba0ef056b0a",
        & parsed.to_string(), "Incorrect string representation"
    );
}
#[test]
/// valid go purl with uppercase in namespace
fn valid_go_purl_with_uppercase_in_namespace() {
    let parsed =
        match Purl::from_str("pkg:golang/github.com/GoogleCloudPlatform/cloud-sql-proxy/v2") {
            Ok(purl) => purl,
            Err(error) => {
                panic!(
                    "Failed to parse valid purl {:?}: {}",
                    "pkg:golang/github.com/GoogleCloudPlatform/cloud-sql-proxy/v2", error
                )
            },
        };
    assert_eq!(&PackageType::Golang, parsed.package_type(), "Incorrect package type");
    assert_eq!(
        Some("github.com/GoogleCloudPlatform/cloud-sql-proxy"),
        parsed.namespace(),
        "Incorrect namespace"
    );
    assert_eq!("v2", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:golang/github.com/GoogleCloudPlatform/cloud-sql-proxy/v2",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// valid go purl with uppercase in name
fn valid_go_purl_with_uppercase_in_name() {
    let parsed = match Purl::from_str("pkg:golang/example.com/A") {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse valid purl {:?}: {}", "pkg:golang/example.com/A", error)
        },
    };
    assert_eq!(&PackageType::Golang, parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("example.com"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("A", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!("pkg:golang/example.com/A", &parsed.to_string(), "Incorrect string representation");
}
#[test]
/// valid go purl without namespace
fn valid_go_purl_without_namespace() {
    let parsed = match Purl::from_str("pkg:golang/v.io") {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse valid purl {:?}: {}", "pkg:golang/v.io", error)
        },
    };
    assert_eq!(&PackageType::Golang, parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("v.io", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!("pkg:golang/v.io", &parsed.to_string(), "Incorrect string representation");
}
#[test]
/// valid npm purl with uppercase in name
fn valid_npm_purl_with_uppercase_in_name() {
    let parsed = match Purl::from_str("pkg:npm/parseUri") {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse valid purl {:?}: {}", "pkg:npm/parseUri", error)
        },
    };
    assert_eq!(&PackageType::Npm, parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("parseUri", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!("pkg:npm/parseUri", &parsed.to_string(), "Incorrect string representation");
}
#[test]
/// valid cargo purl with uppercase in name
fn valid_cargo_purl_with_uppercase_in_name() {
    let parsed = match Purl::from_str("pkg:cargo/Inflector") {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse valid purl {:?}: {}", "pkg:cargo/Inflector", error)
        },
    };
    assert_eq!(&PackageType::Cargo, parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("Inflector", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!("pkg:cargo/Inflector", &parsed.to_string(), "Incorrect string representation");
}
#[test]
/// non-canonical nuget purl with uppercase in name
fn non_canonical_nuget_purl_with_uppercase_in_name() {
    let parsed = match Purl::from_str("pkg:nuget/Newtonsoft.Json") {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse valid purl {:?}: {}", "pkg:nuget/Newtonsoft.Json", error)
        },
    };
    assert_eq!(&PackageType::NuGet, parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("newtonsoft.json", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!("pkg:nuget/newtonsoft.json", &parsed.to_string(), "Incorrect string representation");
}
#[test]
/// non-canonical pypi purl with uppercase in name
fn non_canonical_pypi_purl_with_uppercase_in_name() {
    let parsed = match Purl::from_str("pkg:pypi/PyTest") {
        Ok(purl) => purl,
        Err(error) => {
            panic!("Failed to parse valid purl {:?}: {}", "pkg:pypi/PyTest", error)
        },
    };
    assert_eq!(&PackageType::PyPI, parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("pytest", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!("pkg:pypi/pytest", &parsed.to_string(), "Incorrect string representation");
}
#[test]
/// non-canonical pypi purl with specials in name
fn non_canonical_pypi_purl_with_specials_in_name() {
    let parsed = match Purl::from_str("pkg:pypi/_-.-_special_-.-_name_-.-_") {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:pypi/_-.-_special_-.-_name_-.-_", error
            )
        },
    };
    assert_eq!(&PackageType::PyPI, parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("-special-name-", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!("pkg:pypi/-special-name-", &parsed.to_string(), "Incorrect string representation");
}
#[test]
/// invalid maven purl without namespace
fn invalid_maven_purl_without_namespace() {
    assert!(
        Purl::from_str("pkg:maven/invalid").is_err(),
        "{}",
        "invalid maven purl without namespace"
    );
}
#[test]
/// plus signs and spaces
fn plus_signs_and_spaces() {
    let parsed =
        match Purl::from_str("pkg:cargo/example?repository_url=https://example.com/a%20b+c/") {
            Ok(purl) => purl,
            Err(error) => {
                panic!(
                    "Failed to parse valid purl {:?}: {}",
                    "pkg:cargo/example?repository_url=https://example.com/a%20b+c/", error
                )
            },
        };
    assert_eq!(&PackageType::Cargo, parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("example", parsed.name(), "Incorrect name");
    assert_eq!(None, parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> =
        [("repository_url", "https://example.com/a b+c/")].into_iter().collect();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:cargo/example?repository_url=https://example.com/a%20b%2Bc/",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// unsupported: percent signs are properly encoded and decoded
fn unsupported_percent_signs_are_properly_encoded_and_decoded() {
    assert!(
        matches!(Purl::from_str("pkg:generic/100%25/100%25@100%25?repository_url=https://example.com/100%2525/#100%25"),
        Err(PackageError::UnsupportedType)), "Type {} is not supported", "generic"
    );
    let parsed = match GenericPurl::<String>::from_str(
        "pkg:generic/100%25/100%25@100%25?repository_url=https://example.com/100%2525/#100%25",
    ) {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:generic/100%25/100%25@100%25?repository_url=https://example.com/100%2525/#100%25",
                error
            )
        },
    };
    assert_eq!("generic", parsed.package_type(), "Incorrect package type");
    assert_eq!(Some("100%"), parsed.namespace(), "Incorrect namespace");
    assert_eq!("100%", parsed.name(), "Incorrect name");
    assert_eq!(Some("100%"), parsed.version(), "Incorrect version");
    assert_eq!(Some("100%"), parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> =
        [("repository_url", "https://example.com/100%25/")].into_iter().collect();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:generic/100%25/100%25@100%25?repository_url=https://example.com/100%2525/#100%25",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
#[test]
/// unsupported: version encoding
fn unsupported_version_encoding() {
    assert!(
        matches!(
            Purl::from_str("pkg:generic/name@a%23%2Fb%3F%2Fc%40"),
            Err(PackageError::UnsupportedType)
        ),
        "Type {} is not supported",
        "generic"
    );
    let parsed = match GenericPurl::<String>::from_str("pkg:generic/name@a%23%2Fb%3F%2Fc%40") {
        Ok(purl) => purl,
        Err(error) => {
            panic!(
                "Failed to parse valid purl {:?}: {}",
                "pkg:generic/name@a%23%2Fb%3F%2Fc%40", error
            )
        },
    };
    assert_eq!("generic", parsed.package_type(), "Incorrect package type");
    assert_eq!(None, parsed.namespace(), "Incorrect namespace");
    assert_eq!("name", parsed.name(), "Incorrect name");
    assert_eq!(Some("a#/b?/c@"), parsed.version(), "Incorrect version");
    assert_eq!(None, parsed.subpath(), "Incorrect subpath");
    let expected_qualifiers: HashMap<&str, &str> = HashMap::new();
    assert_eq!(
        expected_qualifiers,
        parsed.qualifiers().iter().map(|(k, v)| (k.as_str(), v)).collect::<HashMap<&str, &str>>()
    );
    assert_eq!(
        "pkg:generic/name@a%23/b%3F/c%40",
        &parsed.to_string(),
        "Incorrect string representation"
    );
}
